<?xml version = '1.0' encoding = 'ISO-8859-1' ?>
<?xml-stylesheet type="text/xsl" href="soot_options.xsl"  ?>
<options>
	<section>
		<name>General Options</name>
		<boolopt>
			<name>Help</name>
			<alias>h</alias>
			<alias>help</alias>
			<short_desc>Display Help and Exit</short_desc>
			<long_desc>This option displays the textual help message and exits immediately without doing any further processing.</long_desc>
		</boolopt>
		<boolopt>
			<name>Version</name>
			<alias>version</alias>
			<short_desc>Display Version Information and Exit</short_desc>
			<long_desc>This option displays the Soot version information and exits immediately without doing any further processing.</long_desc>
		</boolopt>
		<boolopt>
			<name>Verbose</name>
			<alias>v</alias>
			<alias>verbose</alias>
			<short_desc>Verbose Mode</short_desc>
			<long_desc>This option causes Soot to display detailed information about what it is doing.</long_desc>
		</boolopt>
		<boolopt>
			<name>Application Mode</name>
			<alias>app</alias>
			<short_desc>Run in Application Mode</short_desc>
			<long_desc>This option causes Soot to process any application classes referenced by the classes specified on the command line, in addition to the specified classes.</long_desc>
		</boolopt>
                <boolopt>
			<name>Whole-Program Mode</name>
			<alias>w</alias>
			<alias>whole-program</alias>
			<short_desc>Run in Whole-program Mode</short_desc>
			<long_desc>This option causes Soot to run in whole program mode, taking into consideration the whole program when performing optimizations.</long_desc>
                </boolopt>
                <boolopt>
			<name>Debug</name>
			<alias>debug</alias>
			<short_desc>Prints Various Soot Debugging Info</short_desc>
			<long_desc>This option causes Soot to print various debugging information, particularly from the Baf Body Phase and the Jimple Annotation Pack Phase.</long_desc>
                </boolopt>
	</section>
	<section>
		<name>Input Options</name>
		<stropt>
			<name>Soot Classpath</name>
			<alias>cp</alias>
			<alias>soot-class-path</alias>
			<alias>soot-classpath</alias>
			<short_desc>Uses given PATH as the classpath for finding classes for Soot processing.</short_desc>
			<long_desc>Uses given PATH as the classpath for finding classes for Soot processing.</long_desc>
		</stropt>
		<multiopt>
			<name>Input Source Precedence</name>
			<alias>src-prec</alias>
			<value>
				<name>Class File</name>
				<alias>c</alias>
				<alias>class</alias>
				<short_desc>Use class for source of Soot.</short_desc>
				<default/>
			</value>
			<value>
				<name>Jimple File</name>
				<alias>J</alias>
				<alias>jimple</alias>
				<short_desc>Use Jimple for source of Soot.</short_desc>
			</value>
			<short_desc>Sets Source Precedence for Soot</short_desc>
			<long_desc>By default, Soot will resolve classes from .class files. If a class cannot be resolved from a .class file, Soot will attempt to resolve it from a .jimple file. Setting this option to jimple specifies the opposite policy: classes are resolved from .jimple files, and only if this fails will an attempt be made to resolve them from .class files.</long_desc>
		</multiopt>
		<boolopt>
			<name>Allow Phantom References</name>
			<alias>allow-phantom-refs</alias>
			<short_desc>Allow unresolved classes: may cause errors</short_desc>
			<long_desc>This option causes Soot to process a class even if it cannot find classes referenced by that class. This may cause Soot to produce incorrect results.</long_desc>
		</boolopt>
	</section>
	<section>
		<name>Output Options</name>
		<stropt>
			<name>Output Directory</name>
			<alias>d</alias>
			<alias>output-dir</alias>
			<short_desc>Store Produced Files in PATH</short_desc>
			<long_desc>Specifies that the outputted files are to be stored in PATH. The path may be relative to the working directory. This PATH must already exist before running Soot.</long_desc>
		</stropt>
		<multiopt>
			<name>Output Format</name>
			<alias>f</alias>
			<alias>output-format</alias>
			<value>
				<name>Jimple File</name>
				<alias>J</alias>
				<alias>jimple</alias>
				<short_desc>Produces .jimple Files</short_desc>
                <long_desc>Produces .jimple files that contain a textual representation for types in Soot's Jimple internal representation.</long_desc>
			</value>
			<value>
				<name>Jimp File</name>
				<alias>j</alias>
				<alias>jimp</alias>
				<short_desc>Produces .jimp (abbreviated Jimple) Files</short_desc>
        <long_desc>Produces .jimp files which contain an abbreviated
        textual form for Soot's Jimple internal representation.  The
        abbreviated form is easier to read than the non-abbreviated
        counterpart, but may also contain ambiguities; for instance,
        method signatures are not uniquely determined.</long_desc>
			</value>
			<value>
				<name>Shimple File</name>
				<alias>S</alias>
				<alias>shimple</alias>
				<short_desc>Produces .shimple Files</short_desc>
        <long_desc>Produces .shimple files containing the textual
          representation of Soot's SSA Shimple internal
          representation.  Shimple is very similar to Jimple except
          that it supports Phi nodes.</long_desc>
			</value>
			<value>
				<name>Shimp File</name>
				<alias>s</alias>
				<alias>shimp</alias>
				<short_desc>Produce .shimp (abbreviated Shimple) Files</short_desc>
        <long_desc>Produces .shimp files which contain an abbreviated
        textual form for Soot's SSA Shimple internal representation.
        The abbreviated form is easier to read than the
        non-abbreviated counterpart, but may also contain ambiguities;
        for instance, method signatures are not uniquely
        determined.</long_desc>
			</value>
			<value>
				<name>Baf File</name>
				<alias>B</alias>
				<alias>baf</alias>
				<short_desc>Produces .baf Files</short_desc>
                <long_desc>Produces .baf files that contain a textual representation for types in Soot's Baf internal representation.</long_desc>
			</value>
			<value>
				<name>Abbreviated Baf File</name>
				<alias>b</alias>
				<short_desc>Produce .b (abbreviated Baf) Files</short_desc>
                <long_desc>Produces .b files. These contain an abbreviated textual form for Soot's Baf internal representation. It is easier to read than its non-abbreviated counterpart, but can also contain ambiguities; for instance, method signatures are not uniquely determined.</long_desc>
			</value>
			<value>
				<name>Grimple File</name>
				<alias>G</alias>
				<alias>grimple</alias>
				<short_desc>Produce .grimple Files</short_desc>
                <long_desc>Produces .grimple files that contain a textual representation for types in Soot's Grimp internal representation.</long_desc>
			</value>
			<value>
				<name>Grimp File</name>
				<alias>g</alias>
				<alias>grimp</alias>
				<short_desc>Produces .grimp (abbreviated Grimple) Files</short_desc>
        <long_desc>Produces .grimp files which contain an abbreviated
        textual form for Soot's Grimple internal representation.
        The abbreviated form is easier to read than the
        non-abbreviated counterpart, but may also contain ambiguities;
        for instance, method signatures are not uniquely
        determined.</long_desc>
			</value>
			<value>
				<name>Xml File</name>
				<alias>X</alias>
				<alias>xml</alias>
				<short_desc>Produce .xml Files</short_desc>
               <long_desc>Produces .xml files of classes based on the Jimple statements.</long_desc>
			</value>
			<value>
				<name>No Output File</name>
				<alias>n</alias>
				<alias>none</alias>
				<short_desc>Produces No Output</short_desc>
               <long_desc>This option causes Soot to produces no output files.</long_desc>
			</value>
			<value>
				<name>Jasmin File</name>
				<alias>jasmin</alias>
				<short_desc>Produce .jasmin Files</short_desc>
                <long_desc>Produces .jasmin files as output. These can be understood by the jasmin bytecode assembler tool.</long_desc>
			</value>
			<value>
				<name>Class File</name>
				<alias>c</alias>
				<alias>class</alias>
				<default/>
				<short_desc>Produce .class Files</short_desc>
                <long_desc>Produces Java .class files executable under any Java Virtual Machine.</long_desc>
			</value>
			<value>
				<name>Dava Decompiled File</name>
				<alias>d</alias>
				<alias>dava</alias>
				<short_desc>Produce dava decompiled .java files</short_desc>
				<long_desc>Produces dava decompiled .java files.</long_desc>
			</value>
			<short_desc>Sets Output Format for Soot</short_desc>
			<long_desc>This option sets the output format of files Soot will produce or no output.</long_desc>
		</multiopt>
		<boolopt>
			<name>Via Grimp</name>
			<alias>via-grimp</alias>
			<short_desc>Convert Jimple to Bytecode via Grimp Instead of via Baf</short_desc>
			<long_desc>This option converts Jimple to bytecode via Grimp instead of via Baf.</long_desc>
		</boolopt>
		<boolopt>
			<name>Save Tags to XML</name>
			<alias>xml-attributes</alias>
			<short_desc>Save tags to XML attributes for Eclipse</short_desc>
			<long_desc>This option saves a variety of tags which are attached to hosts to an XML file that is later read by Eclipse to show program understanding annotations within Eclipse.</long_desc>
		</boolopt>
	</section>
	<section>
		<name>Processing Options</name>
		<phaseopt>
			<name>Phase Options</name>
			<alias>p</alias>
			<alias>phase-option</alias>
			<short_desc>set run-time option KEY to VALUE for PHASE-NAME</short_desc>
			<long_desc>Sets run-time option KEY to VALUE for PHASE-NAME (default for VALUE is true).</long_desc>
			<phase>
				<name>Jimple Body Creation</name>
				<alias>jb</alias>
                                <class>JBOptions</class>
				<short_desc>Create a <tt>JimpleBody</tt> for each method</short_desc>
                                <long_desc>
Jimple Body Creation creates a <tt>JimpleBody</tt> for each input
method, using either coffi, to read <tt>.class</tt> files, or the
jimple parser, to read <tt>.jimple</tt> files.
</long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
					<short_desc/>
					<long_desc/>
				</boolopt>
				<boolopt>
					<name>Use Original Names</name>
					<alias>use-original-names</alias>
					<short_desc/>
					<long_desc>
Retain the original names for local variables when the source
includes those names.  Otherwise, Soot gives variables generic
names based on their types.
</long_desc>
				</boolopt>
				<sub_phase>
					<name>Local Splitter</name>
					<alias>jb.ls</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
					<short_desc>Associates separate locals with each use-def web</short_desc>
					<long_desc>
The Local Splitter identifies use-def webs for local variables and
introduces new variables so that each disjoint web is associated
with a single local.
</long_desc>
				</sub_phase>
				<sub_phase>
					<name>Jimple Local Aggregator</name>
					<alias>jb.a</alias>
					<short_desc>Removes some unnecessary copies</short_desc>
                                        <long_desc>
<p>
The Jimple Local Aggregator removes some unnecessary copies by
combining some local variables. Essentially, it finds definitions
which have only a single use and, if it is safe to do so, removes
the original definition after replacing the use with the
definition's right-hand side.</p>
<p>
At this stage in <tt>JimpleBody</tt> construction, local
aggregation serves largely to remove the copies to and from stack
variables which simulate load and store instructions in the
original bytecode.</p>
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<long_desc>
Only aggregate locals that represent stack locations in the
original bytecode.  (Stack locals can be distinguished in Jimple
by the <dollar/> character with which their names begin.)
</long_desc>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unused Local Eliminator</name>
					<alias>jb.ule</alias>
					<short_desc>Removes unused locals</short_desc>
                                        <long_desc>
The Unused Local Eliminator phase removes any unused locals from
the method.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<short_desc>Assigns types to locals</short_desc>
                                        <long_desc>
The Type Assigner gives local variables types which will
accommodate the values stored in the variable by the method.
</long_desc>
					<name>Type Assigner</name>
					<alias>jb.tr</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unsplit-originals Local Packer</name>
					<alias>jb.ulp</alias>
					<short_desc>Minimizes number of locals</short_desc>
					<long_desc>
The Unsplit-originals Local Packer executes only when the
`<tt>use-original-names</tt>&apos; option is chosen for the
`<tt>jb</tt>&apos; phase.  The Local Packer attempts to minimize
the number of local variables required in a method by reusing the
same variable for disjoint def-use webs. Conceptually, it is the
inverse of the Local Splitter.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Unsplit Original Locals</name>
						<alias>unsplit-original-locals</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>
Use the variable names in the original source as a guide when
determining how to share local variables among non-interfering
variable usages. This recombines named locals which were split by
the Local Splitter.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Local Name Standardizer</name>
					<alias>jb.lns</alias>
					<short_desc>Gives names to locals</short_desc>
					<long_desc>
The Local Name Standardizer assigns generic names to local variables.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<short_desc/>
						<long_desc>
Only standardizes the names of variables that represent stack
locations in the original bytecode. This becomes the default when
the `<tt>use-original-names</tt>&apos; option is specified for
the `<tt>jb</tt>&apos; phase.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Copy Propagator</name>
					<alias>jb.cp</alias>
					<short_desc>Removes unnecessary copies</short_desc>
					<long_desc>
This phase performs cascaded copy propagation.  
    
If the propagator encounters situations of the form: 
<pre>
  A: a = ...; 
    ...
  B:  x = a;
    ...
  C: ... = ... x; 
</pre>
where <tt>a</tt> and <tt>x</tt> are each defined only once (at
<tt>A</tt> and <tt>B</tt>, respectively), then it can propagate
immediately without checking between <tt>B</tt> and <tt>C</tt>
for redefinitions of <tt>a</tt>.  In
this case the propagator is global.
        
Otherwise, if <tt>a</tt> has multiple definitions then the
propagator checks for redefinitions and propagates copies
only within extended basic blocks.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Regular Locals</name>
						<alias>only-regular-locals</alias>
						<short_desc/>
						<long_desc>
Only propagate copies through ``regular&apos;&apos; locals, that is,
those declared in the source bytecode.
</long_desc>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>
Only propagate copies through locals that represent stack locations in
the original bytecode.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Dead Assignment Eliminator</name>
					<alias>jb.dae</alias>
					<long_desc>
The Dead Assignment Eliminator eliminates assignment statements
to locals whose values are not subsequently used, unless
evaluating the right-hand side of the assignment may cause
side-effects.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>
Only eliminate dead assignments to locals that represent stack
locations in the original bytecode.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Post-copy propagation Unused Local Eliminator</name>
					<alias>jb.cp-ule</alias>
					<short_desc>Removes unused locals</short_desc>
                                        <long_desc>
This phase removes any locals that are unused as a result of copy propagation.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Local Packer</name>
					<alias>jb.lp</alias>
					<short_desc>Minimizes number of locals</short_desc>
					<long_desc>
The Local Packer attempts to minimize the number of local
variables required in a method by reusing the same variable for
disjoint def-use webs. Conceptually, it is the inverse of the
Local Splitter.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>false</default>
					</boolopt>
					<boolopt>
						<name>Unsplit Original Locals</name>
						<alias>unsplit-original-locals</alias>
                                                <default>false</default>
						<long_desc>
Use the variable names in the original source as a guide when
determining how to share local variables across non-interfering
variable usages. This recombines named locals which were split by
the Local Splitter. SHOULD WE ENSURE THAT IF jb.ulp IS ALSO
ENABLED, THEN ITS unsplit-original-locals MATCHES THIS ONE?
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Nop Eliminator</name>
					<alias>jb.ne</alias>
						<long_desc>
Removes <tt>nop</tt> statements from the method.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unreachable Code Eliminator</name>
					<alias>jb.uce</alias>
						<long_desc>
The Unreachable Code Eliminator removes unreachable code and
traps whose catch blocks are empty.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
			</phase>
			<radio_phase>
				<name>Call Graph</name>
				<alias>cg</alias>
                                <class>CGOptions</class>
                                <short_desc>Build a call graph</short_desc>
                                <long_desc>The purpose of this pack is to compute
a call graph. When this pack finishes, a call graph is available in the Scene.
The different phases in this pack are different ways to construct the call
graph. Exactly one phase in this pack may be enabled; Soot will raise an error otherwise.
</long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
				</boolopt>
                                <boolopt>
                                        <name>Safe forName</name>
                                        <alias>safe-forname</alias>
                                        <default>false</default>
                                        <short_desc>Handle Class.forName() calls conservatively</short_desc>
                                        <long_desc>When a program calls
Class.forName(), the named class is resolved, and its static initializer
executed. In many cases, it cannot be determined statically which
class will be loaded, and which static initializer executed. When this
option is set to true, Soot will conservatively assume that any static
initializer could be executed. This may make the call graph very large.
When this option is set to false, any calls to Class.forName() for which
the class cannot be determined statically are not assumed to call any
static initializers.
</long_desc>
                                </boolopt>
                                <boolopt>
                                        <name>Verbose</name>
                                        <alias>verbose</alias>
                                        <default>false</default>
                                        <short_desc>Print warnings about where the call graph may be incomplete</short_desc>
                                        <long_desc>Due to the effects of native methods and reflection, it may not always be possible to construct a fully conservative call graph. Setting this option to true causes Soot to point out the parts of the call graph that may be incomplete, so that they can be checked by hand.
                                        </long_desc>
                                </boolopt>
				<sub_phase>
					<name>Class Hierarchy Analysis</name>
					<alias>cg.cha</alias>
                                        <class>CHAOptions</class>
                                        <short_desc>Build a call graph using Class Hierarchy Analysis</short_desc>
                                        <long_desc>This phase generates uses Class Hierarchy Analysis to generate a call graph.</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
					<boolopt>
						<name>Verbose</name>
						<alias>verbose</alias>
                                                <default>false</default>
                                                <short_desc>Print statistics about the resulting call graph</short_desc>
                                                <long_desc>Setting this option to true causes Soot to print out statistics about the call graph computed by this phase, such as the number of methods determined to be reachable.</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Spark</name>
					<class>SparkOptions</class>
					<alias>cg.spark</alias>
                                        <short_desc>Spark points-to analysis framework</short_desc>
                                        <long_desc>Spark is a flexible points-to analysis framework. Aside from building a call graph, it also generates information about the targets of pointers. For details about Spark, please see <a href="http://www.sable.mcgill.ca/publications/thesis/#olhotakMastersThesis">Ondrej Lhotak's M.Sc. thesis</a>.</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<section>
						<name>Spark General Options</name>
						<boolopt>
							<name>Verbose</name>
							<alias>verbose</alias>
							<default>false</default>
                                                        <short_desc>Print detailed information about the execution of Spark</short_desc>
							<long_desc>
When this option is set to true, Spark prints detailed information about its execution.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Ignore Types Entirely</name>
							<alias>ignore-types</alias>
							<default>false</default>
                                                        <short_desc>Make Spark completely ignore declared types of variables</short_desc>
							<long_desc>
When this option is set to true, all parts of Spark completely ignore
declared types of variables and casts.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Force Garbage Collections</name>
							<alias>force-gc</alias>
							<default>false</default>
                                                        <short_desc>Force garbage collection for measuring memory usage</short_desc>
							<long_desc>
When this option is set to true, calls to System.gc() will be made at
various points to allow memory usage to be measured.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Pre Jimplify</name>
							<alias>pre-jimplify</alias>
							<default>false</default>
                                                        <short_desc>Jimplify all methods before starting Spark</short_desc>
							<long_desc>
When this option is set to true, Spark converts all available methods to Jimple
before starting the points-to analysis. This allows the Jimplification
time to be separated from the points-to time. However, it increases the
total time and memory requirement, because all methods are Jimplified,
rather than only those deemed reachable by the points-to analysis.
        </long_desc>
						</boolopt>
					</section>
					<section>
						<name>Spark Pointer Assignment Graph Building Options</name>
						<boolopt>
							<name>VTA</name>
							<alias>vta</alias>
							<default>false</default>
                                                        <short_desc>Emulate Variable Type Analysis</short_desc>
							<long_desc>
Setting VTA to true has the effect of setting field-based,
types-for-sites, and simplify-sccs to true to simulate Variable Type
Analysis, described in <a href="http://www.sable.mcgill.ca/publications/papers/#oopsla2000">our OOPSLA 2000 paper</a>. Note that the
algorithm differs from the original VTA in that it handles array
elements more precisely.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>RTA</name>
							<alias>rta</alias>
							<default>false</default>
                                                        <short_desc>Emulate Rapid Type Analysis</short_desc>
							<long_desc>
Setting RTA to true sets types-for-sites to true, and causes Spark to use
a single points-to set for all variables, giving <a href="http://doi.acm.org/10.1145/236337.236371">Rapid Type
Analysis</a>.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Field Based</name>
							<alias>field-based</alias>
							<default>false</default>
                                                        <short_desc>Use a field-based rather than field-sensitive representation</short_desc>
							<long_desc>
When this option is set to true, fields are represented by variable
(Green) nodes, and the object that the field belongs to is ignored
(all objects are lumped together), giving a field-based analysis. Otherwise, fields are represented by
field reference (Red) nodes, and the objects that they belong to are
distinguished, giving a field-sensitive analysis.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Types For Sites</name>
							<alias>types-for-sites</alias>
							<default>false</default>
                                                        <short_desc>Represent objects by their actual type rather than allocation site</short_desc>
							<long_desc>
When this option is set to true, types rather than allocation sites are
used as the elements of the points-to sets.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Merge String Buffer</name>
							<alias>merge-stringbuffer</alias>
							<default>true</default>
                                                        <short_desc>Represent all StringBuffers as one object</short_desc>
							<long_desc>
When this option is set to true, all allocation sites creating
<tt>java.lang.StringBuffer</tt> objects are grouped together as a single
allocation site.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Simulate Natives</name>
							<alias>simulate-natives</alias>
							<default>true</default>
                                                        <short_desc>Simulate effects of native methods in standard class library</short_desc>
							<long_desc>
When this option is set to true, the effects of native methods in the standard Java class library are simulated.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Simple Edges Bidirectional</name>
							<alias>simple-edges-bidirectional</alias>
							<default>false</default>
                                                        <short_desc>Equality-based analysis between variable nodes</short_desc>
							<long_desc>
When this option is set to true, all edges connecting variable (Green)
nodes are made bidirectional, as in <a href="http://doi.acm.org/10.1145/237721.237727">Steensgaard&apos;s analysis</a>.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>On Fly Call Graph</name>
							<alias>on-fly-cg</alias>
							<default>true</default>
                                                        <short_desc>Build call graph as receiver types become known</short_desc>
							<long_desc>
When this option is set to true, the call graph is computed on-the-fly
as points-to information is computed. Otherwise, an initial
CHA approximation to the call graph is used.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Parms As Fields</name>
							<alias>parms-as-fields</alias>
							<default>false</default>
                                                        <short_desc>Represent method parameters as fields of this</short_desc>
							<long_desc>
When this option is set to true, parameters to methods are represented
as fields (Red nodes) of the this object; otherwise, parameters are
represented as variable (Green) nodes.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Returns As Fields</name>
							<alias>returns-as-fields</alias>
							<default>false</default>
                                                        <short_desc>Represent method return values as fields of this</short_desc>
							<long_desc>
When this option is set to true, return values from methods are
represented as fields (Red nodes) of the this object; otherwise,
return values are represented as variable (Green) nodes.
        </long_desc>
						</boolopt>
					</section>
					<section>
						<name>Spark Pointer Assignment Graph Simplification Options</name>
						<boolopt>
							<name>Simplify Offline</name>
							<alias>simplify-offline</alias>
							<default>false</default>
                                                        <short_desc>Collapse single-entry subgraphs of the PAG</short_desc>
							<long_desc>
When this option is set to true, variable (Green) nodes which forming
single-entry subgraphs (so they must have the same points-to set) are
merged together before propagation begins.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Simplify SCCs</name>
							<alias>simplify-sccs</alias>
							<default>false</default>
                                                        <short_desc>Collapse strongly-connected components of the PAG</short_desc>
							<long_desc>
When this option is set to true, variable (Green) nodes which form
strongly-connected components (so they must have the same points-to set)
are merged together before propagation begins.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Ignore Types For SCCs</name>
							<alias>ignore-types-for-sccs</alias>
							<default>false</default>
                                                        <short_desc>Ignore declared types when determining node equivalence for SCCs</short_desc>
							<long_desc>
When this option is set to true, when collapsing strongly-connected
components, nodes forming SCCs are collapsed regardless of their declared type.
The collapsed SCC is given the most general type of all the nodes in the
component.

When this option is set to false, only edges connecting nodes of the
same type are considered when detecting SCCs.

This option has no effect unless <tt>simplify-sccs</tt> is true.
        </long_desc>
						</boolopt>
					</section>
					<section>
						<name>Spark Points-To Set Flowing Options</name>
						<multiopt>
							<name>Propagator</name>
							<alias>propagator</alias>
							<value>
								<name>Iter</name>
								<alias>iter</alias>
<short_desc>Simple iterative algorithm</short_desc>
<long_desc>
Iter is a simple, iterative algorithm, which propagates everything until the
graph does not change.
</long_desc>
							</value>
							<value>
								<name>Worklist</name>
								<alias>worklist</alias>
								<default/>
<short_desc>Fast, worklist-based algorithm</short_desc>
<long_desc>
Worklist is a worklist-based algorithm that tries
to do as little work as possible. This is currently the fastest algorithm.
</long_desc>

							</value>
							<value>
								<name>Cycle</name>
								<alias>cycle</alias>
                                                                <short_desc>Unfinished on-the-fly cycle detection algorithm</short_desc>
                                                                <long_desc>This algorithm finds cycles in the PAG on-the-fly. It is not yet finished.</long_desc>
							</value>
							<value>
								<name>Merge</name>
								<alias>merge</alias>
<short_desc>Unfinished field reference merging algorithms</short_desc>
<long_desc>
Merge is an algorithm that merges all concrete field (yellow) nodes with their corresponding
field reference (red) nodes. This algorithm is not yet finished.
</long_desc>
							</value>
							<value>
								<name>Alias</name>
								<alias>alias</alias>
<short_desc>Alias-edge based algorithm</short_desc>
<long_desc>
Alias is an alias-edge based algorithm. This algorithm tends to take
the least memory for very large problems, because it does not represent
explicitly points-to sets of fields of heap objects.
</long_desc>

							</value>
							<value>
								<name>None</name>
								<alias>none</alias>
                                                                <short_desc>Disable propagation</short_desc>
<long_desc>
None means that propagation is not done; the graph is only built and
simplified. This is useful if an external solver is being used to perform the
propagation.
</long_desc>
							</value>
                                                        <short_desc>Select propagation algorithm</short_desc>
							<long_desc>
This option tells Spark which propagation algorithm to use.
        </long_desc>
						</multiopt>
						<multiopt>
							<name>Set Implementation</name>
							<alias>set-impl</alias>
							<value>
								<name>Hash set</name>
								<alias>hash</alias>
                                                                <short_desc>Use Java HashSet</short_desc>

<long_desc>
Hash is an implementation based on Java&apos;s built-in hash-set.
</long_desc>
							</value>
							<value>
								<name>Bit-vector</name>
								<alias>bit</alias>
<short_desc>Bit vector</short_desc>
<long_desc>
Bit is an implementation using a bit vector.
</long_desc>
							</value>
							<value>
								<name>Hybrid</name>
								<alias>hybrid</alias>
<short_desc>Hybrid representation using bit vector for large sets</short_desc>
<long_desc>
Hybrid is an implementation that keeps an explicit list of up to
16 elements, and switches to a bit-vector when the set gets
larger than this.
</long_desc>
							</value>
							<value>
								<name>Sorted array</name>
								<alias>array</alias>
                                                                <short_desc>Sorted array representation</short_desc>
                                                                <long_desc>
Array is an implementation that keeps the elements of the
points-to set in a sorted array. Set membership is tested using
binary search, and set union and intersection are computed using
an algorithm based on the merge step from merge sort.
</long_desc>
							</value>
							<value>
								<name>Double</name>
								<alias>double</alias>
								<default/>
<short_desc>Double set representation for incremental propagation</short_desc>
<long_desc>
Double is an implementation that itself uses a pair of sets for
each points-to set. The first set in the pair stores new pointed-to
objects that have not yet been propagated, while the second set stores
old pointed-to objects that have been propagated and need not be
reconsidered. This allows the propagation algorithms to be incremental,
often speeding them up significantly.
</long_desc>
							</value>
							<value>
								<name>Shared bit-vector</name>
								<alias>shared</alias>
                                                                <short_desc>Shared bit-vector representation</short_desc>
                                                                <long_desc>This is a bit-vector representation, in which duplicate bit-vectors are found and stored only once to save memory.</long_desc>

							</value>
                                                        <short_desc>Select points-to set implementation</short_desc>
							<long_desc>
Selects an implementation of a points-to set that Spark should use.
</long_desc>
						</multiopt>
						<multiopt>
							<name>Double Set Old</name>
							<alias>double-set-old</alias>
							<value>
								<name>Hash set</name>
								<alias>hash</alias>
                                                                <short_desc>Use Java HashSet</short_desc>

<long_desc>
Hash is an implementation based on Java&apos;s built-in hash-set.
</long_desc>
							</value>
							<value>
								<name>Bit-vector</name>
								<alias>bit</alias>
<short_desc>Bit vector</short_desc>
<long_desc>
Bit is an implementation using a bit vector.
</long_desc>
							</value>
							<value>
								<name>Hybrid</name>
								<alias>hybrid</alias>
                                                                <default/>
<short_desc>Hybrid representation using bit vector for large sets</short_desc>
<long_desc>
Hybrid is an implementation that keeps an explicit list of up to
16 elements, and switches to a bit-vector when the set gets
larger than this.
</long_desc>
							</value>
							<value>
								<name>Sorted array</name>
								<alias>array</alias>
                                                                <short_desc>Sorted array representation</short_desc>
                                                                <long_desc>
Array is an implementation that keeps the elements of the
points-to set in a sorted array. Set membership is tested using
binary search, and set union and intersection are computed using
an algorithm based on the merge step from merge sort.
</long_desc>
							</value>
							<value>
								<name>Shared bit-vector</name>
								<alias>shared</alias>
                                                                <short_desc>Shared bit-vector representation</short_desc>
                                                                <long_desc>This is a bit-vector representation, in which duplicate bit-vectors are found and stored only once to save memory.</long_desc>

							</value>
                                                        <short_desc>Select implementation of points-to set for old part of double set</short_desc>
							<long_desc>
Selects an implementation for the sets of old objects in the double
points-to set implementation.

This option has no effect unless <tt>set-impl</tt> is set to double.
        </long_desc>
						</multiopt>
						<multiopt>
							<name>Double Set New</name>
							<alias>double-set-new</alias>
							<value>
								<name>Hash set</name>
								<alias>hash</alias>
                                                                <short_desc>Use Java HashSet</short_desc>

<long_desc>
Hash is an implementation based on Java&apos;s built-in hash-set.
</long_desc>
							</value>
							<value>
								<name>Bit-vector</name>
								<alias>bit</alias>
<short_desc>Bit vector</short_desc>
<long_desc>
Bit is an implementation using a bit vector.
</long_desc>
							</value>
							<value>
								<name>Hybrid</name>
								<alias>hybrid</alias>
                                                                <default/>
<short_desc>Hybrid representation using bit vector for large sets</short_desc>
<long_desc>
Hybrid is an implementation that keeps an explicit list of up to
16 elements, and switches to a bit-vector when the set gets
larger than this.
</long_desc>
							</value>
							<value>
								<name>Sorted array</name>
								<alias>array</alias>
                                                                <short_desc>Sorted array representation</short_desc>
                                                                <long_desc>
Array is an implementation that keeps the elements of the
points-to set in a sorted array. Set membership is tested using
binary search, and set union and intersection are computed using
an algorithm based on the merge step from merge sort.
</long_desc>
							</value>
							<value>
								<name>Shared bit-vector</name>
								<alias>shared</alias>
                                                                <short_desc>Shared bit-vector representation</short_desc>
                                                                <long_desc>This is a bit-vector representation, in which duplicate bit-vectors are found and stored only once to save memory.</long_desc>

							</value>
                                                        <short_desc>Select implementation of points-to set for new part of double set</short_desc>
							<long_desc>
Selects an implementation for the sets of new objects in the double
points-to set implementation.

This option has no effect unless setImpl is set to double.
        </long_desc>
						</multiopt>
					</section>
					<section>
						<name>Spark Output Options</name>
						<boolopt>
							<name>Dump HTML</name>
							<alias>dump-html</alias>
							<default>false</default>
                                                        <short_desc>Dump pointer assignment graph to HTML for debugging</short_desc>
							<long_desc>
When this option is set to true, a browseable HTML representation of the
pointer assignment graph is output to a file called <tt>pag.jar</tt> after the analysis completes. Note
that this representation is typically very large.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Dump PAG</name>
							<alias>dump-pag</alias>
							<default>false</default>
                                                        <short_desc>Dump pointer assignment graph for other solvers</short_desc>
							<long_desc>
When this option is set to true, a representation of the pointer assignment graph
suitable for processing with other solvers (such as the BDD-based solver) is
output before the analysis begins.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Dump Solution</name>
							<alias>dump-solution</alias>
							<default>false</default>
                                                        <short_desc>Dump final solution for comparison with other solvers</short_desc>
							<long_desc>
When this option is set to true, a representation of the resulting points-to
sets is dumped. The format is similar to that of the <tt>dump-pag</tt>
option, and is therefore suitable for comparison with the results of other
solvers.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Topological Sort</name>
							<alias>topo-sort</alias>
							<default>false</default>
                                                        <short_desc>Sort variable nodes in dump</short_desc>
							<long_desc>
When this option is set to true, the representation dumped by the dump-pag option
is dumped with the variable (green) nodes in (pseudo-)topological order.

This option has no effect unless dump-pag is true.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Dump Types</name>
							<alias>dump-types</alias>
							<default>true</default>
                                                        <short_desc>Include declared types in dump</short_desc>
							<long_desc>
When this option is set to true, the representation dumped by the dump-pag option
includes type information for all nodes.

This option has no effect unless dump-pag is true.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Class Method Var</name>
							<alias>class-method-var</alias>
							<default>true</default>
                                                        <short_desc>In dump, label variables by class and method</short_desc>
							<long_desc>
When this option is set to true, the representation dumped by the dump-pag option
represents nodes by numbering each class, method, and variable within
the method separately, rather than assigning a single integer to each
node.

This option has no effect unless dump-pag is true.
Setting class-method-var to true has the effect of setting topo-sort to false.
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Dump Answer</name>
							<alias>dump-answer</alias>
							<default>false</default>
                                                        <short_desc>Dump computed reaching types for comparison with other solvers</short_desc>
							<long_desc>
When this option is set to true, the computed reaching types for each variable are
dumped to a file, so that they can be compared with the results of
other analyses (such as the old VTA).
        </long_desc>
						</boolopt>
						<boolopt>
							<name>Add Tags</name>
							<alias>add-tags</alias>
							<default>false</default>
                                                        <short_desc>Output points-to results in tags for viewing with the Jimple</short_desc>
							<long_desc>
        When this option is set to true, the results of the analysis are encoded inside
tags, and printed with the resulting Jimple code.

        </long_desc>
						</boolopt>
						<boolopt>
							<name>Calculate Set Mass</name>
							<alias>set-mass</alias>
							<default>false</default>
                                                        <short_desc>Calculate statistics about points-to set sizes</short_desc>
							<long_desc>
When this option is set to true, Spark computes and prints various
cryptic statistics about the size of the points-to sets computed.
        </long_desc>
						</boolopt>
					</section>
				</sub_phase>
			</radio_phase>

<!-- DISABLED FOR NOW ++
			<phase>
				<name>Whole Shimple Transformation Pack</name>
				<alias>wstp</alias>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
          <default>true</default>
				</boolopt>
			</phase>
			<phase>
				<name>Whole Shimple Optimization Pack</name>
				<alias>wsop</alias>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
          <default>false</default>
				</boolopt>
			</phase>
++ DISABLED FOR NOW -->

			<phase>
				<name>Whole-Jimple Transformation Pack</name>
				<alias>wjtp</alias>
				<long_desc>
Soot can do whole-program analyses.  For the current version of Soot,
this means that Jimple bodies are created for each method in the
application, and analyses run on this set of Jimple bodies.  The
application consists of one class, specified on the command-line, plus
all classes referenced (directly or indirectly) by it.  It excludes
classes in <tt>java.*</tt>, <tt>javax.*</tt>, and <tt>sun.*</tt>.  This mode is
triggered by the <tt>-</tt><tt>-app</tt> option.

In whole-program mode, Soot applies the contents of the
Whole-Jimple Transformation Pack to each method under analysis.
This occurs after all Jimple bodies have been created.  In an
unmodified version of Soot, the only transformation in
<tt>wjtp</tt> is the Spark pointer analysis kit. Spark has many
options, which are listed at <a
href="http://www.sable.mcgill.ca/soot/tutorial/phase-options/spark.ps">spark.ps</a>.

                        </long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
					<short_desc/>
					<long_desc/>
				</boolopt>
			</phase>
			<phase>
				<name>Whole-Jimple Optimization Pack</name>
				<alias>wjop</alias>
				<long_desc>
To run optimizing transformations on the whole program, use the <tt>-W</tt>
command-line option.  This tells Soot to apply Whole-Jimple
Optimization Pack.

The default behaviour of this Pack has static method binding disabled
and static inlining enabled.  To reverse this, give the options
<tt>-p wjop.smb enabled:true -p wjop.si disabled</tt>.

                        </long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
					<default>false</default>
					<short_desc/>
					<long_desc/>
				</boolopt>
				<sub_phase>
					<name>Static Method Binding</name>
					<class>SMBOptions</class>
					<alias>wjop.smb</alias>
					<long_desc>
Static method binding uses CHA or VTA to statically bind 
monomorphic call sites. That is, smb takes the call graph returned
by CHA or VTA; if the analysis result shows that any virtual invoke
statement in the Jimple bodies actually only calls one method, then a
static copy of the method is made, and the virtual invoke is changed
to a static invoke.

                        </long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Insert Null Checks</name>
						<alias>insert-null-checks</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>
The receiver object is checked for nullness before the
target method is invoked.  If the target is null, then a NullPointer
exception is thrown.
                        </long_desc>
					</boolopt>
					<boolopt>
						<name>Insert Redundant Casts</name>
						<alias>insert-redundant-casts</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>
Inserts extra casts for the verifier.  The verifier will
complain if the target uses `this&apos; (so we have to pass an extra
parameter), and the argument passed to the method is not the same
type.  For instance, <tt>Bottle.price<uscore/>static</tt> is a method which takes a
Cost object, and Cost is an interface implemented by Bottle.  We must
then cast the Cost to a Bottle before passing it to <tt>price<uscore/>static</tt>.
                        </long_desc>
					</boolopt>
					<multiopt>
						<name>Allow Modifier Changes</name>
						<alias>allowed-modifier-changes</alias>
						<value>
							<name>Unsafe</name>
							<alias>unsafe</alias>
							<short_desc/>
							<default/>
						</value>
						<value>
							<name>Safe</name>
							<alias>safe</alias>
							<short_desc/>
						</value>
						<value>
							<name>None</name>
							<alias>none</alias>
							<short_desc/>
						</value>
						<short_desc/>
						<long_desc>
Determines what changes in visibility modifiers
are allowed.  ``unsafe&apos;&apos; modifies the visibility on code so that
all inlining is permitted; some IllegalAccessErrors may be missed.
``safe&apos;&apos; preserves the exact meaning of the analysed program, 
and ``none&apos;&apos; changes no modifiers whatsoever.
                        </long_desc>
					</multiopt>
				</sub_phase>
				<sub_phase>
					<name>Static Inlining</name>
					<class>SIOptions</class>
					<alias>wjop.si</alias>
					<long_desc>
The StaticInliner takes an call graph returned by CHA or VTA and visits
all call sites in the application in a bottom-up fashion, inlining 
invoke statements which is determined to be monomorphic by analysis result.
Note that the modifier ``static&apos;&apos; is supposed to be compared to a
(not-currently-implemented) profile-guided inliner.
 
                        </long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Insert Null Checks</name>
						<alias>insert-null-checks</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>As in <tt>StaticMethodBinder</tt>.</long_desc>
					</boolopt>
					<boolopt>
						<name>Insert Redundant Casts</name>
						<alias>insert-redundant-casts</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>As in <tt>StaticMethodBinder</tt>.</long_desc>
					</boolopt>
					<multiopt>
						<name>Allow Modifier Changes</name>
						<alias>allowed-modifier-changes</alias>
						<value>
							<name>Unsafe</name>
							<alias>unsafe</alias>
							<short_desc/>
							<default/>
						</value>
						<value>
							<name>Safe</name>
							<alias>safe</alias>
							<short_desc/>
						</value>
						<value>
							<name>None</name>
							<alias>none</alias>
							<short_desc/>
						</value>
						<short_desc/>
						<long_desc>As in <tt>StaticMethodBinder</tt>.</long_desc>
					</multiopt>
					<flopt>
						<name>Expansion Factor</name>
						<alias>expansion-factor</alias>
						<default>3</default>
						<short_desc/>
						<long_desc>
Determines the maximum allowed expansion of a method.  Inlining
will cause the method to grow by a factor of no more than
expansion-factor.
                        </long_desc>
					</flopt>
					<intopt>
						<name>Max Container Size</name>
						<alias>max-container-size</alias>
						<default>5000</default>
						<short_desc/>
						<long_desc>
Determines the maximum number of Jimple statements for a container
method.  If a method has more than this number of Jimple statements,
then no methods will be inlined into it.
                        </long_desc>
					</intopt>
					<intopt>
						<name>Max Inlinee Size</name>
						<alias>max-inlinee-size</alias>
						<default>20</default>
						<short_desc/>
						<long_desc>
Determines the maximum number of Jimple statements for an inlinee
method.  If a method has more than this number of Jimple statements,
then it will not be inlined into other methods.
                        </long_desc>
					</intopt>
				</sub_phase>
			</phase>
			<phase>
				<name>Whole-Jimple Annotation Pack</name>
				<alias>wjap</alias>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                    <default>true</default>
					<long_desc>
Some analyses do not transform Jimple body directly, but annotate
statements or values with tags. Whole-Jimple annotation pack provides
a place for annotation-oriented analysis in a whole program mode.
					</long_desc>
				</boolopt>
				<sub_phase>
					<name>Rectangular Array Finder</name>
					<alias>wjap.ra</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc> Find array variables always pointing to rectangular two-dimensional array objects. </short_desc>
						<long_desc> 
In Java, a multi-dimensional array is an array of arrays, which means
the shape of the array can be ragged. However, many applications use
rectangular arrays. Such information is very helpful in proving 
safe array bounds checks. Rectangular array finder traverses Jimple
statements based on static call graph, and finds array variables 
always holding rectangular two-dimensional array objects. 
The analysis results are used by array bounds check elimination (jap.abc).
This phase does not change the program.
						</long_desc>
					</boolopt>
				</sub_phase>
			</phase>
      <phase>
        <name>Shimple Phase Options</name>
        <alias>shimple</alias>
        <class>ShimpleOptions</class>
        <short_desc>General Shimple options.</short_desc>
        <long_desc>These options affect the Shimple body behaviour --
          currently the only available options affect Shimple during Phi 
	  node elimination.</long_desc>
        <boolopt>
          <name>Enabled</name>
          <alias>enabled</alias>
          <default>true</default>
        </boolopt>
        <multiopt>
          <name>Phi Node Elimination Optimizations</name>
          <alias>phi-elim-opt</alias>
          <short_desc>Options affecting Phi node
            elimination.</short_desc>
          <long_desc>These options control Shimple's behaviour when
            eliminating Phi nodes.</long_desc>
          <value>
            <name>Naive Phi Node Elimination</name>
            <alias>none</alias>
            <short_desc>If enabled, no optimizations are applied
            before or after eliminating Phi nodes.</short_desc>
            <long_desc>If set to true, neither pre-optimization nor
              post-optimization will be applied to the Phi elimination
              process.  This is useful for monitoring and understanding
              the behaviour of Shimple optimizations or transformations.
              Note that setting this option to true takes precedence over
              other Phi elimination options.</long_desc>
          </value>
          <value>
            <name>Pre-optimize Phi Elimination</name>
            <alias>pre</alias>
            <short_desc>If enabled, some optimizations are applied
              before Phi nodes are eliminated.</short_desc>
            <long_desc>If set to true, some recommended optimizations
              such as dead code elimination and local packing are applied
              before Phi node elimination.  This does not appear to be as
              effective as post-optimization, but the option is provided
              for future testing and investigation.</long_desc>
          </value>
          <value>
            <name>Post-optimize Phi Elimination</name>
            <alias>post</alias>
            <default/>
            <short_desc>If enabled, some optimizations are applied after
              Phi nodes are eliminated.</short_desc>
            <long_desc>Applies recommended optimizations such as dead
              code elimination and local packing after Phi node
              elimination.  This appears to be more effective than
              pre-optimization.</long_desc>
          </value>
          <value>
            <name>Pre- and Post- Optimize Phi Elimination</name>
            <alias>pre-and-post</alias> 
            <short_desc>If enabled, some optimizations are applied
            both before and after Phi nodes are eliminated.</short_desc>
            <long_desc>Applies recommended optimizations such as dead
            code elimination and local packing both before and after
            Phi node elimination.  Provided for
            experimentation.</long_desc>
          </value>
        </multiopt>
      </phase>
			<phase>
				<name>Shimple Transformation Pack</name>
				<alias>stp</alias>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
          <short_desc>When enabled, Shimple-based transformations are applied.</short_desc>
          <long_desc>If the Shimple phase is enabled, Soot applies the
          contents of the Shimple Transformation Pack to each method
          under analysis.  This pack contains no transformations in an
          unmodified version of Soot.</long_desc>
          <default>true</default>
				</boolopt>
			</phase>
			<phase>
				<name>Shimple Optimization Pack</name>
				<alias>sop</alias>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
          <default>false</default>
          <short_desc>When enabled, Shimple-based optimizations are
          applied.</short_desc>
          <long_desc>When enabled, Soot applies the Shimple
          Optimization Pack to every <tt>ShimpleBody</tt> in
          application classes.  This section lists the default
          transformations in the Shimple Optimization
          Pack.</long_desc>
				</boolopt>
				<sub_phase>
					<name>Constant Propagator and Folder</name>
					<alias>sop.cpf</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
            <default>true</default>
						<short_desc>An example optimization written for
						Shimple.</short_desc>
						<long_desc>An example implementation of constant
						propagation using Shimple. Informal tests show that this
						analysis is already more powerful than the simplistic
						ConstantPropagatorAndFolder optimization provided by
						Jimple, particularly when control flow is involved.  This
						optimization demonstrates some of the benefits of SSA --
						particularly the fact that Phi nodes represent natural
						merge points in the control flow.  This implementation
						also demonstrates how to access U/D and D/U chains in
						Shimple.</long_desc>
					</boolopt>
				</sub_phase>
			</phase>
			<phase>
				<name>Jimple Transformation Pack</name>
				<alias>jtp</alias>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
					<short_desc/>
					<long_desc>
Soot applies the contents of the Jimple Transformation Pack to
each method under analysis.  This pack contains no
transformations in an unmodified version of Soot.
</long_desc>
				</boolopt>
			</phase>
			<phase>
				<name>Jimple Optimization Pack</name>
				<alias>jop</alias>
				<long_desc>
When Soot is given the <tt>-O</tt> or <tt>-optimize</tt>
command-line option, it applies the
Jimple Optimization Pack to every <tt>JimpleBody</tt> in
application classes.  This section lists the default
transformations in the Jimple Optimization Pack.
</long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>false</default>
					<short_desc/>
					<long_desc/>
				</boolopt>
				<sub_phase>
					<name>Common Subexpression Eliminator</name>
					<alias>jop.cse</alias>
					<long_desc>
<p>
The Common Subexpression Eliminator runs an available expressions
analysis on the method body, then eliminates common
subexpressions.
</p>
<p>
This implementation is especially slow, as it runs on individual
statements rather than on basic blocks.  A better implementation
(which would find most common subexpressions, but not all) would use
basic blocks instead.
</p>
<p>
This implementation is also slow because the flow universe is
explicitly created; it need not be.  A better implementation
would implicitly compute the kill sets at every node.
</p>
<p>
Because of the current slowness, this transformation is not
enabled by default.
</p>
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Naive Side Effect Tester</name>
						<alias>naive-side-effect</alias>
						<short_desc>Use a naive side effect analysis even if interprocedural information is available</short_desc>
						<long_desc>
<p>
If <tt>naive-side-effect</tt> is set to <tt>true</tt> the Common
Subexpression Eliminator uses the conservative side effect
information provided by the <tt>NaiveSideEffectTester</tt> class,
even if interprocedural information about side effects is
available.</p>
<p>
The naive side effect analysis is based solely on the information
available locally about a statement. It assumes, for example,
that any method call has the potential to write and read all
instance and static fields in the program.</p>
<p>
If <tt>naive-side-effect</tt> is set to <tt>false</tt> and whole
program analysis has been specified by the <tt>-W</tt> or
<tt>-whole-program</tt> options, then the Common Subexpression
Eliminator uses the side effect information provided by the
<tt>PASideEffectTester</tt> class. <tt>PASideEffectTester</tt>
uses the information provided by a points-to analysis to
determine which fields and statics may be written or read by a
given statement.</p>
<p>
If whole program analysis is not performed, naive side effect
information is used regardless of the setting of
<tt>naive-side-effect</tt>.
</p>
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Busy Code Motion</name>
					<alias>jop.bcm</alias>
					<class>BCMOptions</class>
					<long_desc>
Busy Code Motion is a straightforward implementation of Partial
Redundancy Elimination. This implementation is not very
aggressive.  Lazy Code Motion is an improved version which
should be used instead of Busy Code Motion.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Naive Side Effect Tester</name>
						<alias>naive-side-effect</alias>
						<short_desc>Use a naive side effect analysis even if interprocedural information is available</short_desc>
						<long_desc>
<p>
If <tt>naive-side-effect</tt> is set to <tt>true</tt> Busy Code
Motion uses the conservative side effect information provided by
the <tt>NaiveSideEffectTester</tt> class, even if interprocedural
information about side effects is available.</p>
<p>
The naive side effect analysis is based solely on the information
available locally about a statement. It assumes, for example,
that any method call has the potential to write and read all
instance and static fields in the program.</p>
<p>
If <tt>naive-side-effect</tt> is set to <tt>false</tt> and whole
program analysis has been specified by the <tt>-W</tt> or
<tt>-whole-program</tt> options, then Busy Code Motion uses the
side effect information provided by the
<tt>PASideEffectTester</tt> class. <tt>PASideEffectTester</tt>
uses the information provided by a points-to analysis to
determine which fields and statics may be written or read by a
given statement.</p>
<p>
If whole program analysis is not performed, naive side effect
information is used regardless of the setting of
<tt>naive-side-effect</tt>.
</p>
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Lazy Code Motion</name>
					<class>LCMOptions</class>
					<alias>jop.lcm</alias>
					<long_desc>
Lazy Code Motion is an enhanced version of Busy Code Motion, a
Partial Redundancy Eliminator. Before doing Partial Redundancy Elimination,
this optimization performs loop inversion (turning <tt>while</tt> loops
into <tt>do while</tt> loops inside an <tt>if</tt> statement).
This allows the Partial Redundancy Eliminator
to optimize loop invariants of <tt>while</tt> loops.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<multiopt>
						<name>Safety</name>
						<alias>safety</alias>
						<value>
							<name>Safe</name>
							<alias>safe</alias>
							<short_desc/>
							<long_desc>
Safe, but only considers moving additions,
subtractions and multiplications.
</long_desc>
							<default/>
						</value>
						<value>
							<name>Medium</name>
							<alias>medium</alias>
							<short_desc/>
							<long_desc>
Unsafe in multi-threaded programs, as it may reuse the values
read from field accesses.
</long_desc>
						</value>
						<value>
							<name>Unsafe</name>
							<alias>unsafe</alias>
							<short_desc/>
							<long_desc>
May violate Java's exception semantics, as it may move or reorder
exception-throwing statements, potentially outside of
<tt>try-catch</tt> blocks.
</long_desc>
						</value>
						<short_desc/>
						<long_desc>
This option controls which fields and statements are candidates
for code motion.
</long_desc>
					</multiopt>
					<boolopt>
						<name>Unroll</name>
						<alias>unroll</alias>
						<short_desc/>
						<long_desc>
If <tt>true</tt>, perform loop inversion before doing the
transformation.
</long_desc>
						<default>true</default>
					</boolopt>
					<boolopt>
						<name>Naive Side Effect Tester</name>
						<alias>naive-side-effect</alias>
						<short_desc>Use a naive side effect analysis even if interprocedural information is available</short_desc>
						<long_desc>
<p>
If <tt>naive-side-effect</tt> is set to <tt>true</tt> Lazy Code
Motion uses the conservative side effect information provided by
the <tt>NaiveSideEffectTester</tt> class, even if interprocedural
information about side effects is available.</p>
<p>
The naive side effect analysis is based solely on the information
available locally about a statement. It assumes, for example,
that any method call has the potential to write and read all
instance and static fields in the program.</p>
<p>
If <tt>naive-side-effect</tt> is set to <tt>false</tt> and whole
program analysis has been specified by the <tt>-W</tt> or
<tt>-whole-program</tt> options, then Lazy Code Motion uses the
side effect information provided by the
<tt>PASideEffectTester</tt> class. <tt>PASideEffectTester</tt>
uses the information provided by a points-to analysis to
determine which fields and statics may be written or read by a
given statement.</p>
<p>
If whole program analysis is not performed, naive side effect
information is used regardless of the setting of
<tt>naive-side-effect</tt>.
</p>
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Copy Propagator</name>
					<class>CPOptions</class>
					<alias>jop.cp</alias>
					<short_desc>Removes unnecessary copies</short_desc>
					<long_desc>
<p>
This phase performs cascaded copy propagation.</p>
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Regular Locals</name>
						<alias>only-regular-locals</alias>
						<short_desc/>
						<long_desc>
Only propagate copies through ``regular&apos;&apos; locals, that is,
those declared in the source bytecode.
</long_desc>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<short_desc/>
						<long_desc>
Only propagate copies through locals that represent stack locations in
the original bytecode.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Constant Propagator and Folder</name>
					<alias>jop.cpf</alias>
					<short_desc/>
					<long_desc>
The Constant Propagator and Folder evaluates any expressions
consisting entirely of compile-time constants, for example <tt>2
* 3</tt>, and replaces the expression with the constant result,
in this case <tt>6</tt>.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Conditional Branch Folder</name>
					<alias>jop.cbf</alias>
					<long_desc>
The Conditional Branch Folder statically evaluates the
conditional expression of Jimple <tt>IfStmt</tt>s.  If the
condition is identically `<tt>true</tt>&apos; or
`<tt>false</tt>&apos;, the Folder replaces the conditional branch
statement with an unconditional `<tt>goto</tt>&apos; statement.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Dead Assignment Eliminator</name>
					<alias>jop.dae</alias>
					<long_desc>
The Dead Assignment Eliminator eliminates assignment statements
to locals whose values are not subsequently used, unless
evaluating the right-hand side of the assignment may cause
side-effects.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unreachable Code Eliminator 1</name>
					<alias>jop.uce1</alias>
					<long_desc>
The Unreachable Code Eliminator removes unreachable code and
traps whose catch blocks are empty.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unconditional Branch Folder 1</name>
					<alias>jop.ubf1</alias>
					<long_desc>
<p>
The Unconditional Branch Folder removes unnecessary `<tt>goto</tt>&apos;
statements from a <tt>JimpleBody</tt>.</p>
<p>
If a <tt>GotoStmt</tt>&apos;s target is the next instruction,
then it is removed.  If a <tt>GotoStmt</tt>&apos;s target is
another <tt>GotoStmt</tt>, with target <tt>y</tt>, then the first
statement&apos;s target is changed to <tt>y</tt>&apos;.</p>
<p>
If some <tt>IfStmt</tt>&apos;s target is a <tt>GotoStmt</tt>,
then the <tt>IfStmt</tt>&apos;s target can be updated to the
<tt>GotoStmt</tt>&apos;s target.</p>
<p>
(These situations can result from other optimizations, and folding
branches may itself generate more unreachable code.)</p>
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unreachable Code Eliminator 2</name>
					<alias>jop.uce2</alias>
					<long_desc>
Another iteration of the Unreachable Code Eliminator.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unconditional Branch Folder 2</name>
					<alias>jop.ubf2</alias>
					<long_desc>
Another iteration of the Unconditional Branch Folder.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unused Local Eliminator</name>
					<alias>jop.ule</alias>
					<short_desc>Removes unused locals</short_desc>
					<long_desc>
The Unused Local Eliminator phase removes any unused locals from
the method.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
			</phase>
			<phase>
				<name>Jimple Annotation Pack</name>
				<alias>jap</alias>
				<long_desc>
Soot has a number of phase options to configure the annotation process.
Array bounds check and null pointer check detection have 
separate phases and phase options.
                        </long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
				</boolopt>
				<sub_phase>
					<name>Null Pointer Check Options</name>
					<class>NPCOptions</class>
					<alias>jap.npc</alias>
					<long_desc>
The null pointer check analysis has the phase name <tt>jtp.npc</tt>. 
It has one phase option (aside from the default <tt>disabled</tt> option). 
                        </long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Array Ref</name>
						<alias>only-array-ref</alias>
						<short_desc/>
						<long_desc>
  By default, all bytecodes that need null pointer checks 
  are annotated with the analysis result. When this option 
  is set to true, Soot will annotate only array-referencing 
  bytecodes with null pointer check information; other bytecodes, 
  such as <tt>getfield</tt> and <tt>putfield</tt>, will not be annotated. 
                        </long_desc>
					</boolopt>
					<boolopt>
						<name>Profiling</name>
						<alias>profiling</alias>
						<short_desc>Insert profiling instructions counting the number of safe null pointer accesses.</short_desc>
						<long_desc>
If this option is true, the analysis inserts profiling instructions
counting the number of eliminated safe null pointer checks at runtime.
This is only for profiling purpose.
						</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Array Bound Check Options</name>
					<class>ABCOptions</class>
					<alias>jap.abc</alias>
					<long_desc>
The array bounds check analysis has the phase name <tt>jtp.abc</tt>. 
If whole-program analysis is required, an extra
phase <tt>wjap.ra</tt> for finding rectangular arrays occurs.
                        </long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>With All</name>
						<alias>with-all</alias>
						<short_desc/>
						<long_desc>
A macro.  Instead of typing a long string of phase options, this option 
will turn on all options of the phase ``<tt>jap.abc</tt>&apos;&apos;.
                        </long_desc>
					</boolopt>
					<boolopt>
						<name>With Field References</name>
						<alias>with-fieldref</alias>
						<short_desc/>
						<long_desc>
The analysis treats field references (static and instance) as common
subexpressions. The restrictions from the `<tt>with-arrayref</tt>&apos; option also
apply. 
                        </long_desc>
					</boolopt>
					<boolopt>
						<name>With Array References</name>
						<alias>with-arrayref</alias>
						<short_desc/>
						<long_desc>
With this option enabled, array
references can be considered as common subexpressions; however, we are
more conservative when writing into an array, because array
objects may be aliased. NOTE: We also assume that the application in a
single-threaded program or in a synchronized block. That is, an
array element may not be changed by other threads between two array
references.
                        </long_desc>
					</boolopt>
					<boolopt>
						<name>With Common Sub-expressions</name>
						<alias>with-cse</alias>
						<short_desc/>
						<long_desc>
The analysis will consider common subexpressions.  For example,
  consider the situation where <tt>r1</tt> is assigned <tt>a*b</tt>; later,
  <tt>r2</tt> is assigned <tt>a*b</tt>, where both <tt>a</tt> and <tt>b</tt> have
  not been changed between the two statements. The analysis can
  conclude that <tt>r2</tt> has the same value as <tt>r1</tt>. Experiments
  show that this option can improve the result slightly.
                        </long_desc>
					</boolopt>
					<boolopt>
						<name>With Class Field</name>
						<alias>with-classfield</alias>
						<short_desc/>
						<long_desc>
This option makes the analysis work on the class level. The algorithm 
analyzes `final&apos; or `private&apos; class fields first. It can recognize
the fields that hold array objects with constant length.  In an application 
using lots of array fields, this option can improve the analysis results 
dramatically. 

                        </long_desc>
					</boolopt>
					<boolopt>
						<name>With Rectangular Array</name>
						<alias>with-rectarray</alias>
						<short_desc/>
						<long_desc>
This option is used together with "wjap.ra" to make Soot run the whole-program
analysis for rectangular array objects. This analysis is based on the
call graph, and it usually takes a long time. If the application uses
rectangular arrays, these options can improve the analysis
result.
                        </long_desc>
					</boolopt>
					<boolopt>
						<name>Profiling</name>
						<alias>profiling</alias>
						<short_desc>Profile the results of array bounds check analysis.</short_desc>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Profiling Generator</name>
					<alias>jap.profiling</alias>
					<class>ProfilingOptions</class>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Not Main Entry</name>
						<alias>notmainentry</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Side effect tagger</name>
					<alias>jap.sea</alias>
					<class>SETOptions</class>
                                        <long_desc>Uses the active invoke graph to
produce side-effect attributes as described in the <a href="http://www.sable.mcgill.ca/publications/thesis/#olhotakMastersThesis">Spark thesis</a>, chapter 6.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Build naive dependence graph</name>
						<alias>naive</alias>
						<default>false</default>
						<short_desc/>
						<long_desc>When set to true, the
dependence graph is built with a node for each statement, without merging the
nodes for equivalent statements. The purpose of this switch is to make it possible
to measure the effect of merging nodes for equivalent statements on the size
of the dependence graph.</long_desc>
					</boolopt>
				</sub_phase>
                                <sub_phase>
					<name>Field Read/Write Tagger</name>
                                        <class>FRWOptions</class>
					<alias>jap.fieldrw</alias>
					<long_desc>
Uses the active invoke graph to produce tags indicating which fields may
be read or written by each statement, including invoke statements.
                        </long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<intopt>
						<name>Maximum number of fields</name>
						<alias>threshold</alias>
                                                <default>100</default>
						<short_desc/>
						<long_desc>
If a statement reads/writes more than this number of fields, no tag will be
produced for it, in order to keep the size of the tags reasonable.
                        </long_desc>
					</intopt>
				</sub_phase>
				<sub_phase>
					<name>Call Graph Tagger</name>
					<alias>jap.cgtagger</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
			</phase>
			<phase>
				<name>Grimp Body Creation</name>
				<alias>gb</alias>
				<long_desc>
The Grimp Body Creation phase creates a <tt>GrimpBody</tt> for
each source method. It is run only if the output format is <tt>grimp</tt> or <tt>grimple</tt>, or if class files are being output and the <tt>via-grimp</tt> option has been specified.
</long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
					<short_desc/>
					<long_desc/>
				</boolopt>
				<sub_phase>
					<name>Grimp Pre-folding Aggregator</name>
					<alias>gb.a1</alias>
	  				<long_desc>
The Grimp Pre-folding Aggregator combines some local variables,
finding definitions with only a single use and removing the
definition after replacing the use with the definition's
right-hand side, if it is safe to do so. While the mechanism is
the same as that employed by the Jimple Local Aggregator, there
is more scope for aggregation because of Grimp's more complicated
expressions.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>
Aggregate only values stored in stack locals.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Grimp Constructor Folder</name>
					<alias>gb.cf</alias>
					<long_desc>
The Grimp Constructor Folder combines <tt>new</tt> statements
with the <tt>specialinvoke</tt> statement that calls the new
object's constructor. For example, it turns
<pre>
r2 = new java.util.ArrayList;
r2.<lt/>init<gt/>();
</pre>
into
<pre>
r2 = new java.util.ArrayList();
</pre>
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Grimp Post-folding Aggregator</name>
					<alias>gb.a2</alias>
	  				<long_desc>
The Grimp Post-folding Aggregator combines local variables after
constructors have been folded. Constructor folding typically
introduces new opportunities for aggregation, since when a
sequence of instructions like
<pre>
r2 = new java.util.ArrayList;
r2.<lt/>init<gt/>();
r3 = r2
</pre>
is replaced by
<pre>
r2 = new java.util.ArrayList();
r3 = r2
</pre>
the invocation of <tt><lt/>init<gt/></tt> no longer represents a potential side-effect 
separating the two definitions, so they can be combined into
<pre>
r3 = new java.util.ArrayList();
</pre>
(assuming there are no subsequent uses of <tt>r2</tt>
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
					<boolopt>
						<name>Only Stack Locals</name>
						<alias>only-stack-locals</alias>
						<default>true</default>
						<short_desc/>
						<long_desc>
Aggregate only values stored in stack locals.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Grimp Unused Local Eliminator</name>
					<alias>gb.ule</alias>
					<short_desc>Removes unused locals</short_desc>
                                        <long_desc>
This phase removes any locals that are unused after constructor
folding and aggregation.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
			</phase>
			<phase>
				<name>Grimp Optimization</name>
				<alias>gop</alias>
				<long_desc>
The Grimp Optimization pack performs optimizations on <tt>GrimpBody</tt>s (currently there are no optimizations performed specifically on <tt>GrimpBody</tt>s, and the pack is empty). It is run only if the output format is <tt>grimp</tt> or <tt>grimple</tt>, or if class files are being output and the <tt>via-grimp</tt> option has been specified.
</long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>false</default>
				</boolopt>
			</phase>
			<phase>
				<name>Baf Body Creation</name>
				<alias>bb</alias>
				<long_desc>
The Baf Body Creation phase creates a
<tt>BafBody</tt> from each source method. It is
run if the output format is <tt>baf</tt> or <tt>b</tt>, or
if class files are being output and the <tt>via-grimp</tt> option
has not been specified.
</long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
				</boolopt>
				<sub_phase>
					<name>Load Store Optimizer</name>
					<alias>bb.lso</alias>
				<long_desc>
The Load Store Optimizer replaces some combinations of loads to and stores from local variables with stack instructions. A simple example would be the replacement of
<pre>
store.r $r2;
load.r $r2;
</pre>
with 
<pre>
dup1.r
</pre>
in cases where the value of <tt><dollar/>r2</tt> is not used subsequently.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
					<boolopt>
						<name>Debug</name>
						<alias>debug</alias>
	    					<long_desc>
Produces voluminous debugging output describing the progress of
the load store optimizer.
</long_desc>
					</boolopt>
					<boolopt>
						<name>Inter</name>
						<alias>inter</alias>
	    					<long_desc>
Enables two simple inter-block optimizations which attempt to
keep some variables on the stack between blocks.  Both are
intended to catch <tt>if</tt>-like constructions where control
flow branches temporarily into two paths that converge at a later
point.
</long_desc>
					</boolopt>
					<boolopt>
						<name>sl</name>
						<alias>sl</alias>
	    					<long_desc>
Enables an optimization which attempts to eliminate
<tt>store</tt>/<tt>load</tt> pairs.
</long_desc>
						<default>true</default>
					</boolopt>
					<boolopt>
						<name>sl2</name>
						<alias>sl2</alias>
	    					<long_desc>
Enables an a second pass of the optimization which attempts to
eliminate <tt>store</tt>/<tt>load</tt> pairs.
</long_desc>
					</boolopt>
					<boolopt>
						<name>sll</name>
						<alias>sll</alias>
	    					<long_desc>
Enables an optimization which attempts to eliminate 
<tt>store</tt>/<tt>load</tt>/<tt>load</tt>
trios with some variant of <tt>dup</tt>.
</long_desc>
						<default>true</default>
					</boolopt>
					<boolopt>
						<name>sll2</name>
						<alias>sll2</alias>
						<long_desc>
Enables an a second pass of the optimization which attempts to
eliminate <tt>store</tt>/<tt>load</tt>/<tt>load</tt> trios with
some variant of <tt>dup</tt>.
</long_desc>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Peephole Optimizer</name>
					<alias>bb.pho</alias>
					<long_desc>
Applies peephole optimizations to the Baf intermediate
representation.  Individual optimizations must be implemented by
classes implementing the <tt>Peephole</tt> interface. The
Peephole Optimizer reads the names of the <tt>Peephole</tt>
classes at runtime from the file <tt>peephole.dat</tt> and loads
them dynamically. Then it continues to run apply the
<tt>Peephole</tt>s repeatedly until none of them are able to
perform any further optimizations.
<p>
Soot provides only one <tt>Peephole</tt>, named
<tt>ExamplePeephole</tt>, which is not enabled by the delivered
<tt>peephole.dat</tt> file.
<tt>ExamplePeephole</tt> removes all <tt>checkcast</tt>
instructions.</p>
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Unused Local Eliminator</name>
					<alias>bb.ule</alias>
					<short_desc>Removes unused locals</short_desc>
                                        <long_desc>
This phase removes any locals that are unused after load store optimization
and peephole optimization.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Local Packer</name>
					<alias>bb.lp</alias>
					<short_desc>Minimizes number of locals</short_desc>
					<long_desc>
The Local Packer attempts to minimize the number of local
variables required in a method by reusing the same variable for
disjoint def-use webs. Conceptually, it is the inverse of the
Local Splitter.
</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
                                                <default>true</default>
					</boolopt>
					<boolopt>
						<name>Unsplit Original Locals</name>
						<alias>unsplit-original-locals</alias>
						<long_desc>
Use the variable names in the original source as a guide when
determining how to share local variables across non-interfering
variable usages. This recombines named locals which were split by
the Local Splitter. SHOULD WE ENSURE THAT IF jb.ulp IS ALSO
ENABLED, THEN ITS unsplit-original-locals MATCHES THIS ONE?
</long_desc>
					</boolopt>
				</sub_phase>
			</phase>
			<phase>
				<name>Baf Optimization</name>
				<alias>bop</alias>
				<long_desc>
The Baf Optimization pack performs optimizations on
<tt>BafBody</tt>s (currently there are no optimizations performed
specifically on <tt>BafBody</tt>s, and the pack is empty). It is
run only if the output format is <tt>baf</tt> or <tt>b</tt>, or
if class files are being output and the <tt>via-grimp</tt> option
has not been specified.
</long_desc>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>false</default>
				</boolopt>
			</phase>
			<phase>
				<name>Tag</name>
				<alias>tag</alias>
				<boolopt>
					<name>Enabled</name>
					<alias>enabled</alias>
                                        <default>true</default>
				</boolopt>
				<sub_phase>
					<name>Line Number Tag Aggregator</name>
					<alias>tag.ln</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Array Bounds and Null Pointer Check Tag Aggregator</name>
					<alias>tag.an</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
				<sub_phase>
					<name>Dependence Tag Aggregator</name>
					<alias>tag.dep</alias>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
                                <sub_phase>
					<name>Field Read/Write Tag Aggregator</name>
					<alias>tag.fieldrw</alias>
                                        <long_desc>Aggregates field read/write
tags produced by the Field Read/Write Tagger, phase <tt>jap.fieldrw</tt>.</long_desc>
					<boolopt>
						<name>Enabled</name>
						<alias>enabled</alias>
						<default>false</default>
						<short_desc/>
						<long_desc/>
					</boolopt>
				</sub_phase>
			</phase>
		</phaseopt>
		<macroopt>
			<name>Optimize</name>
			<alias>O</alias>
			<alias>optimize</alias>
			<expansion>-p</expansion>
                        <expansion>gb.a1</expansion>
                        <expansion>only-stack-locals:false</expansion>
			<expansion>-p</expansion>
                        <expansion>gb.a2</expansion>
                        <expansion>only-stack-locals:false</expansion>
			<expansion>-p</expansion>
                        <expansion>bop</expansion>
                        <expansion>enabled:true</expansion>
			<expansion>-p</expansion>
                        <expansion>gop</expansion>
                        <expansion>enabled:true</expansion>
			<expansion>-p</expansion>
                        <expansion>jop</expansion>
                        <expansion>enabled:true</expansion>
			<expansion>-p</expansion>
                        <expansion>sop</expansion>
                        <expansion>enabled:true</expansion>
			<short_desc>perform scalar optimizations on the classfiles</short_desc>
			<long_desc>Perform scalar optimizations on the classfiles.</long_desc>
		</macroopt>
		<macroopt>
			<name>Whole Program Optimize</name>
			<alias>W</alias>
			<alias>whole-optimize</alias>
			<expansion>-p</expansion>
                        <expansion>wjop</expansion>
                        <expansion>enabled:true</expansion>
                        <expansion>-w</expansion>
			<short_desc>perform whole program optimizations on the classfiles</short_desc>
			<long_desc>Perform whole program optimizations on the classfiles; this also enables -O.</long_desc>
		</macroopt>
		<boolopt>
			<name>Via Shimple</name>
			<alias>via-shimple</alias>
			<short_desc>enables phases operating on Shimple SSA representation</short_desc>
			<long_desc>This option ... </long_desc>
		</boolopt>
	</section>
	<section>
		<name>Single File Mode Options</name>
		<listopt>
			<name>Process Path</name>
			<alias>process-path</alias>
			<short_desc>Process all Classes on the PATH</short_desc>
			<long_desc>Process all classes in PATH. All the classes found in PATH will be loaded and transformed in single-file mode.
</long_desc>
		</listopt>
	</section>
	<section>
		<name>Application Mode Options</name>
		<listopt>
			<name>Include Package</name>
			<alias>i</alias>
			<alias>include</alias>
			<short_desc>Marks Classfiles in PACKAGE (e.g. java.util.) as Application Classes</short_desc>
			<long_desc>Marks the classfiles in PACKAGE (e.g. java.util.) as application classes. This option can be used to transform library types which by default are not transformed by Soot.</long_desc>
		</listopt>
		<listopt>
			<name>Exclude Package</name>
			<alias>x</alias>
			<alias>exclude</alias>
			<short_desc>Marks Classfiles in PACKAGE (e.g. java.) as Context Classes</short_desc>
			<long_desc>Marks classfiles in PACKAGE (e.g. java.) as context classes. Jimple is not produced for context classes, but the SootClass, SootField and SootMethod signature objects are created.</long_desc>
		</listopt>
		<listopt>
			<name>Dynamic Classes</name>
			<alias>dynamic-classes</alias>
			<short_desc>Marks CLASSES (separated by colons) as Potentially Dynamic Classes</short_desc>
			<long_desc>This option marks CLASSES (separated by colons) as potentially dynamic classes. </long_desc>
		</listopt>
		<listopt>
			<name>Dynamic Path</name>
			<alias>dynamic-path</alias>
			<short_desc>Marks all Class Files in PATH as Potentially Dynamic Classes</short_desc>
			<long_desc>Marks all class files in PATH as potentially dynamic classes. This allows aggressive optimization of applications for which the set of dynamic classes that can be loaded is known at compile time.</long_desc>
		</listopt>
		<listopt>
			<name>Dynamic Package</name>
			<alias>dynamic-package</alias>
			<short_desc>Marks Class Files in PACKAGES (separated by commas) as Potentially Dynamic Classes</short_desc>
			<long_desc>Marks all class files belonging to a package listed in PACKAGES (or one of its subpackages) as potentially dynamic classes.</long_desc>
		</listopt>
	</section>
	<section>
		<name>Input Attribute Options</name>
		<boolopt>
			<name>Keep Line Number</name>
			<alias>keep-line-number</alias>
			<short_desc>Keep Line Number Tables</short_desc>
			<long_desc>Preserves the line number tables of class files throughout the  transformations.</long_desc>
		</boolopt>
		<boolopt>
			<name>Keep Bytecode Offset</name>
			<alias>keep-bytecode-offset</alias>
			<alias>keep-offset</alias>
			<short_desc>Attach Bytecode Offset to Jimple Statement</short_desc>
			<long_desc>Preserves the bytecode offset tables of class files throughout the transformations.</long_desc>
		</boolopt>
	</section>
	<section>
		<name>Annotation Options</name>
		<macroopt>
			<name>Null Pointer Annotation</name>
			<alias>annot-nullpointer</alias>
			<expansion>-p</expansion>
                        <expansion>jap.npc</expansion>
                        <expansion>enabled:true</expansion>
                        <expansion>-p</expansion>
                        <expansion>tag.an</expansion>
                        <expansion>enabled:true</expansion>
			<short_desc>Turn on the Annotation for Null Pointer</short_desc>
			<long_desc>This option turns on annotations for Null Pointer. This creates annotations that can be added to class files and later used by the JVM.</long_desc>
		</macroopt>
		<macroopt>
			<name>Array Bounds Annotation</name>
			<alias>annot-arraybounds</alias>
			<expansion>-p</expansion>
                        <expansion>wjap.ra</expansion>
                        <expansion>enabled:true</expansion>
                        <expansion>-p</expansion>
                        <expansion>jap.abc</expansion>
                        <expansion>enabled:true</expansion>
                        <expansion>-p</expansion>
                        <expansion>tag.an</expansion>
                        <expansion>enabled:true</expansion>
			<short_desc>Turn on the Annotation for Array Bounds Check</short_desc>
			<long_desc>This option turns on annotations for Array Bound Check. This creates annotations that can be added to class files and later used by the JVM.</long_desc>
		</macroopt>
		<macroopt>
			<name>Side effect annotation</name>
			<alias>annot-side-effect</alias>
                        <expansion>-w</expansion>
			<expansion>-p</expansion>
                        <expansion>jap.sea</expansion>
                        <expansion>enabled:true</expansion>
                        <expansion>-p</expansion>
                        <expansion>tag.dep</expansion>
                        <expansion>enabled:true</expansion>
			<short_desc>Turn on Side-effect Attributes</short_desc>
			<long_desc>This option turns on the generation of side-effect attributes.</long_desc>
		</macroopt>
		<macroopt>
			<name>Field read/write annotation</name>
			<alias>annot-fieldrw</alias>
                        <expansion>-w</expansion>
			<expansion>-p</expansion>
                        <expansion>jap.fieldrw</expansion>
                        <expansion>enabled:true</expansion>
                        <expansion>-p</expansion>
                        <expansion>tag.fieldrw</expansion>
                        <expansion>enabled:true</expansion>
			<short_desc>Turn on Field Read/Write Attributes</short_desc>
			<long_desc>This option turns on the generation of field read/write attributes.</long_desc>
		</macroopt>
	</section>
	<section>
		<name>Miscellaneous Options</name>
		<boolopt>
			<name>Time</name>
			<alias>time</alias>
			<short_desc>Print out Time Statistics about Tranformations</short_desc>
			<long_desc>Print out time statistics about transformations.</long_desc>
		</boolopt>
		<boolopt>
			<name>Subtract Garbage Collection Time</name>
			<alias>subtract-gc</alias>
			<short_desc>Attempt to Subtract the gc from the Time Stats</short_desc>
			<long_desc>Attempt to subtract garbage-collection time from the time stats.</long_desc>
		</boolopt>
	</section>
</options>
