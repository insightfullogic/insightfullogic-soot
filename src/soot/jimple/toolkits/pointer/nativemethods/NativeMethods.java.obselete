/**
 * This package contains simulation of native method side-effect
 * in Sun's JDK 1.3.1_01.
 *
 * Each method simulates the side-effect of a real native method
 * by using operations defined in AbstractReference.java.
 *
 * The simulation is flow-insensitive. Most of them are simple, and 
 * without flow info at all. But a few of them (e.g., String.intern()) 
 * has complex native implemenation. 
 *
 * Exceptions are not considered.
 *
 * Each native method maps to a simulating method if it has side-effects:
 *
 *   name : <package>+<method name>, e.g., java.lang.Object.getClass
 *          has a simulating method called java_lang_Object_getClass
 *          (the aming scheme for inner classes: replacing '$' by '_')
 * 
 *   parameters : two fixed variable plus parameters
 *          @thisVar, represents the receiver variable. It is null for 
 *                   a static method.
 *          @returnVar, represents the return variable. It is null
 *                   if the method has no reference type return value.
 *          @param0, @param1, ...,  follows the signature of the method.
 *                   For an non-reference or unused reference parameter, 
 *                   the caller can pass in a null object.
 *
 * Unlisted native methods are handled by 
 *          _default (@thisVar, @returnVar, @params[]);
 *   which does nothing right now.
 * 
 * @author Feng Qian
 */
package soot.jimple.toolkits.pointer.nativemethods;

import soot.*;

public class NativeMethods {
  /*********************** java.lang.Object *********************/
  /**
   * The return variable is assigned an abstract object represneting
   * all classes (UnknowClassObject) from environment.
   *
   * public final native java.lang.Class getClass();
   */
  public static void java_lang_Object_getClass(ReferenceVariable thisVar,
					       ReferenceVariable returnVar) {
    returnVar.isAssignedObject(Environment.getUnknownClassObject());
  }

  /**
   * Creates and returns a copy of this object. The precise meaning of
   * "copy" may depend on the class of the object. The general intent
   * is that, for any object x, the expression:
   * 
   *      x.clone() != x
   *
   * will be true, and that the expression:
   *
   *      x.clone().getClass() == x.getClass()
   *
   * will be true, but these are not absolute requirements. While it is
   * typically the case that:
   *
   *      x.clone().equals(x)
   *
   * will be true, this is not an absolute requirement. Copying an
   * object will typically entail creating a new instance of its
   * class, but it also may require copying of internal data
   * structures as well. No constructors are called.
   *
   * NOTE: it may raise an exception, the decision of cloning made by
   *       analysis by implementing the ReferneceVariable.cloneObject()
   *       method.
   *
   * protected native java.lang.Object clone() 
   *                  throws java.lang.CloneNotSupported
   */
  public static void java_lang_Object_clone(ReferenceVariable thisVar,
					    ReferenceVariable returnVar) {
    ReferenceVariable newValue = thisVar.cloneObject();
    returnVar.isAssigned(thisVar);
  }

  /**
   * Following methods have NO side effect
   *
   * private static native void registerNatives();
   * public native int hashCode();
   * public final native void notify();
   * public final native void notifyAll();
   * public final native void wait(long) 
   *              throws java.lang.InterruptedException;
   */

  /*********************  java.lang.System *********************/
  /** 
   * NOTE: this native method is not documented in JDK API. 
   *       It should have the side effect:
   *       System.in = parameter
   *
   * private static native void setIn0(java.io.InputStream);
   */
  public static void java_lang_System_setIn0(ReferenceVariable thisVar,
					     ReferenceVariable returnVar,
					     ReferenceVariable param0) {
    ReferenceVariable sysIn = 
      NativeHelper.staticField("<java.lang.System in>");
    sysIn.isAssigned(param0);
  }

  /**
   * NOTE: the same explanation as setIn0:
   *       System.out = parameter
   *
   * private static native void setOut0(java.io.PrintStream);
   */
  public static void java_lang_System_setOut0(ReferenceVariable thisVar,
					      ReferenceVariable returnVar,
					      ReferenceVariable param0) {
    ReferenceVariable sysOut = 
      NativeHelper.staticField("<java.lang.System out>");
    sysOut.isAssigned(param0);
  }

  /**
   * NOTE: the same explanation as setIn0:
   *       System.err = parameter
   *
   * private static native void setErr0(java.io.PrintStream);  
   */
  public static void java_lang_System_setErr0(ReferenceVariable thisVar,
					      ReferenceVariable returnVar,
					      ReferenceVariable param0) {
    ReferenceVariable sysErr = 
      NativeHelper.staticField("<java.lang.System err>");
    sysErr.isAssigned(param0);
  }

  /**
   * Copies an array from the specified source array, beginning at the
   * specified position, to the specified position of the destination
   * array.  
   *
   * NOTE: If the content of array is reference type, then it is
   *       necessary to build a connection between elements of
   *       two arrays
   *              
   *       dst[] = src[]
   *
   *  public static native void arraycopy(java.lang.Object, 
   *                                      int, 
   *                                      java.lang.Object, 
   *                                      int, 
   *                                      int);
   */
  public static void java_lang_System_arraycopy(ReferenceVariable thisVar,
						ReferenceVariable returnVar,
						ReferenceVariable param0,
						ReferenceVariable param1,
						ReferenceVariable param2,
						ReferenceVariable param3,
						ReferenceVariable param4) {
    
    ReferenceVariable srcElm = param0.arrayElement();
    ReferenceVariable dstElm = param2.arrayElement();
    dstElm.isAssigned(srcElm);
  }

  /**
   * NOTE: this method is not documented, it should do following:
   *       @return = System.props;
   *       System.props = parameter;
   *
   * private static native 
   *         java.util.Properties initProperties(java.util.Properties);
   */
  public static 
    void java_lang_System_initProperties(ReferenceVariable thisVar,
					 ReferenceVariable returnVar,
					 ReferenceVariable param0) {
    ReferenceVariable sysProps = 
      NativeHelper.staticField("<java.lang.System props>");
    returnVar.isAssigned(sysProps);
    sysProps.isAssigned(param0);
  }

  /**
   * NOTE: it is platform-dependent, create a new string, needs to be verified.
   *
   * public static native java.lang.String mapLibraryName(java.lang.String);
   */
  public static 
    void java_lang_System_mapLibraryName(ReferenceVariable thisVar,
					 ReferenceVariable returnVar,
					 ReferenceVariable param0) {
    returnVar.isAssignedObject(Environment.getUnknownStringObject());
  }

  /**
   * Undocumented, used by class loading.
   *
   * static native java.lang.Class getCallerClass();
   */
  public static 
    void java_lang_System_getCallerClass(ReferenceVariable thisVar,
					 ReferenceVariable returnVar) {
    returnVar.isAssignedObject(Environment.getUnknownClassObject());
  }

  /**
   * Following methods have NO side effects.
   *
   * private static native void registerNatives(); 
   * public static native long currentTimeMillis();
   * public static native int identityHashCode(java.lang.Object);
   */

  /************************ java.lang.Runtime *********************/
  /**
   * execInternal is called by all exec method.
   * It return a Process object.
   *
   * NOTE: creates a Process object.
   *
   * private native 
   *   java.lang.Process execInternal(java.lang.String[], 
   *                                  java.lang.String[], 
   *                                  java.lang.String) 
   *                          throws java.io.IOException;
   */
  public static 
    void java_lang_Runtime_execInternal(ReferenceVariable thisVar,
					ReferenceVariable returnVar,
					ReferenceVariable param0,
					ReferenceVariable param1,
					ReferenceVariable param2) {
    returnVar.isAssignedObject(Environment.getProcessObject());
  }

  /**
   * Following methods have NO side effects.
   *
   *    public native long freeMemory();
   *    public native long totalMemory();
   *    public native void gc();
   *    private static native void runFinalization0();
   *    public native void traceInstructions(boolean);
   *    public native void traceMethodCalls(boolean);
   */

  /************************** java.lang.Shutdown *********************/
  /**
   * Both methods has NO side effects.
   *
   *    static native void halt(int);
   *    private static native void runAllFinalizers();
   */

  /************************** java.lang.String ***********************/
  /**
   * Returns a canonical representation for the string object.  A pool
   * of strings, initially empty, is maintained privately by the class
   * String.
   *
   * When the intern method is invoked, if the pool already contains a
   * * string equal to this String object as determined by the *
   * equals(Object) method, then the string from the pool is *
   * returned. Otherwise, this String object is added to the pool and
   * a * reference to this String object is returned.
   *
   * It follows that for any two strings s and t, 
   *       s.intern() == t.intern() 
   * is true if and only if s.equals(t) is true.
   *
   * All literal strings and string-valued constant expressions are *
   * interned. String literals are defined in §3.10.5 of the Java *
   * Language Specification Returns: a string that has the same
   * contents * as this string, but is guaranteed to be from a pool of
   * unique * strings.
   *
   * Side Effect: from the description, we can see, it is tricky to
   *              know the side effect of this native method.
   *              Take a conservative way to handle this.
   *
   *              It may be @return = this;
   *                         pool = this;
   *   
   * why should we care about String in points-to analysis?
   *
   * public native java.lang.String intern();
   */
  public static void java_lang_String_intern(ReferenceVariable thisVar,
					     ReferenceVariable returnVar) {
    returnVar.isAssignedObject(Environment.getUnknownStringObject());
  }

  /************************** java.lang.Float ***********************/
  /**
   * Following methods have no side effects.
   *    public static native int floatToIntBits(float);
   *    public static native int floatToRawIntBits(float);
   *    public static native float intBitsToFloat(int);
   */

  /************************** java.lang.Double **********************/
  /**
   * Following methods have no side effects.
   *    public static native long doubleToLongBits(double);
   *    public static native long doubleToRawLongBits(double);
   *    public static native double longBitsToDouble(long);
   */

  /************************* java.lang.StrictMath *******************/
  /**
   * Methods have no side effects.
   *
   *    public static native strictfp double sin(double);
   *    public static native strictfp double cos(double);
   *    public static native strictfp double tan(double);
   *    public static native strictfp double asin(double);
   *    public static native strictfp double acos(double);
   *    public static native strictfp double atan(double);
   *    public static native strictfp double exp(double);
   *    public static native strictfp double log(double);
   *    public static native strictfp double sqrt(double);
   *    public static native strictfp double IEEEremainder(double, double);
   *    public static native strictfp double ceil(double);
   *    public static native strictfp double floor(double);
   *    public static native strictfp double rint(double);
   *    public static native strictfp double atan2(double, double);
   *    public static native strictfp double pow(double, double);
  */

  /************************** java.lang.Throwable *******************/
  /**
   * NOTE: this method just fills in the stack state in this throwable 
   *       object content.
   *
   * public native java.lang.Throwable fillInStackTrace();
   */
  public static 
    void java_lang_Throwable_fillInStackTrace(ReferenceVariable thisVar,
					      ReferenceVariable returnVar) {
    returnVar.isAssigned(thisVar);
  }

  /**
   * NO side effects.
   * 
   * private native void printStackTrace0(java.lang.Object);
   */

  /****************************** java.lang.Class **********************/
  /* A quick note for simulating java.lang.Class :
   *
   * In theory, the same class may have two or more representations 
   * at the runtime. But statically, we can assume that all variables
   * of java.lang.Class type are aliased together. By looking at
   * static class hierarchy, there is only one ReferenceVariable 
   * variable for a class in the hierarchy.
   */

  /**
   * NOTE: the semantic of forName0 follows forName method.  
   * 
   * Returns the Class object associated with the class or interface
   * with the given string name, using the given class loader. Given
   * the fully qualified name for a class or interface (in the same
   * format returned by getName) this method attempts to locate,
   * load, and link the class or interface. The specified class
   * loader is used to load the class or interface. If the parameter
   * loader is null, the class is loaded through the bootstrap class
   * loader. The class is initialized only if the initialize
   * parameter is true and if it has not been initialized earlier.
   *
   * If name denotes a primitive type or void, an attempt will be made
   * to locate a user-defined class in the unnamed package whose
   * name is name. Therefore, this method cannot be used to obtain
   * any of the Class objects representing primitive types or void.
   * 
   * If name denotes an array class, the component type of the array
   * class is loaded but not initialized.
   *
   * For example, in an instance method the expression: 
   *       Class.forName("Foo")       
   * is equivalent to: 
   *       Class.forName("Foo", true, this.getClass().getClassLoader()) 
   *
   * private static native java.lang.Class forName0(java.lang.String, 
   *                                                boolean, 
   *                                                java.lang.ClassLoader) 
   *                                throws java.lang.ClassNotFoundException;
   */
  public static void java_lang_Class_forName0(ReferenceVariable thisVar,
					      ReferenceVariable returnVar,
					      ReferenceVariable param0,
					      ReferenceVariable param1,
					      ReferenceVariable param2) {
    returnVar.isAssignedObject(Environment.getUnknownClassObject());
  }

  /**
   * NOTE: creates an object.
   *
   * private native java.lang.Object newInstance0() 
   *           throws java.lang.InstantiationException, 
   *                  java.lang.IllegalAccessException
   */
  public static void java_lang_Class_newInstance0(ReferenceVariable thisVar,
						  ReferenceVariable returnVar){
    returnVar.isAssignedObject(thisVar.newInstance());
  }

  /**
   * Returns the class name.
   *
   * public native java.lang.String getName();
   */
  public static void java_lang_Class_getName(ReferenceVariable thisVar,
					     ReferenceVariable returnVar) {
    returnVar.isAssginedObject(Environment.getUnknownStringObject());
  }

  /**
   * returns the class loader object for this class.
   * 
   * it is almost impossible to distinguish the dynamic class loader
   * for classes. a conservative way is to use one static representation
   * for all class loader, which means all class loader variable aliased
   * together.
   *
   * private native java.lang.ClassLoader getClassLoader0();
   */
  public static 
    void java_lang_Class_getClassLoader0(ReferenceVariable thisVar,
					 ReferenceVariable returnVar) {
    returnVar.isAssignedObject(Environment.getClassLoaderObject());
  }

  /**
   * returns the super class of this class
   *
   * public native java.lang.Class getSuperclass();
   */
  public static 
    void java_lang_Class_getSuperclass(ReferenceVariable thisVar,
				       ReferenceVariable returnVar) {
    returnVar.isAssignedObject(Environment.getUnknownClassObject());
  }

  /**
   * Determines the interfaces implemented by the class or interface
   * represented by this object.
   *
   * Should get an unknown array object.  
   *
   * public native java.lang.Class getInterfaces()[];
   */
  public static 
    void java_lang_Class_getInterfaces(ReferenceVariable thisVar,
				       ReferenceVariable returnVar) {
    /* TODO */
  }

  /**
   * Returns the Class representing the component type of an array. If
   * this class does not represent an array class this method returns
   * null.  
   *
   *     public native java.lang.Class getComponentType();
   */
  public static 
    void java_lang_Class_getComponentType(ReferenceVariable thisVar,
					  ReferenceVariable returnVar) {
    returnVar.isAssignedObject(Environment.getUnknownClassObject());
  }

  /**
   * Gets the signers of this class.
   *
   *     public native java.lang.Object getSigners()[];
   */
  public static 
    void java_lang_Class_getSigners(ReferenceVariable thisVar,
				    ReferenceVariable returnVar) {
    /* TODO */
  }

  /**
   * Sets the signers of a class. This should be called after defining a
   * class.  Parameters: 
   *           c - the Class object 
   *     signers - the signers for the class
   *
   *     native void setSigners(java.lang.Object[]); 
   */
  public static 
    void java_lang_Class_setSigners(ReferenceVariable thisVar,
				    ReferenceVariable param0) {
    /* TODO */
  }

  /**
   * If the class or interface represented by this Class object is a
   * member of another class, returns the Class object representing the
   * class in which it was declared. This method returns null if this
   * class or interface is not a member of any other class. If this
   * Class object represents an array class, a primitive type, or
   * void,then this method returns null.
   *
   *  Returns:
   *      the declaring class for this class
   *
   *     public native java.lang.Class getDeclaringClass(); 
   */
  public static 
    void java_lang_Class_getDeclaringClass(ReferenceVariable thisVar,
					   ReferenceVariable returnVar) {
    returnVar.isAssignedObject(Environment.getUnknownClassObject());
  }

  /**
   * Sets or returns the ProtectionDomain of this class,
   * called by getProtectiondomain.
   * 
   * We need an artificial field variable to handle this.
   *
   *     native void setProtectionDomain0(java.security.ProtectionDomain);
   */
  public static 
    void java_lang_Class_setProtectionDomain0(ReferenceVariable thisVar,
					      ReferenceVariable returnVar,
					      ReferenceVariable param0) {
    /* TODO */
  } 

  /**
   *     private native java.security.ProtectionDomain getProtectionDomain0();
   */
  public static 
    void java_lang_Class_getProtectionDomain0(ReferenceVariable thisVar,
					      ReferenceVariable returnVar) {
    /* TODO */
  }

  /**
   * Undocumented. It is supposed to return a class object for primitive
   * type named by @param0.
   * 
   *     static native java.lang.Class getPrimitiveClass(java.lang.String);
   */
  public static 
    void java_lang_Class_getPrimitiveClass(ReferenceVariable thisVar,
					   AbstraceReference returnVar,
					   ReferenceVariable param0) {
    returnVar.isAssignedObject(Environment.getUnknownClassObject());
  }

  /**
   * Returns an array containing Field objects reflecting all the
   * accessible public fields of the class or interface represented by
   * this Class object.  
   *
   *     private native java.lang.reflect.Field getFields0(int)[];
   */
  public static 
    void java_lang_Class_getFields0(ReferenceVariable thisVar,
				    ReferenceVariable returnVar,
				    ReferenceVariable param0) {
    /* TODO */
  }

  /**
   * Returns an array containing Method objects reflecting all the
   * public member methods of the class or interface represented by
   * this Class object, including those declared by the class or
   * interface and and those inherited from superclasses and
   * superinterfaces.
   *
   *     private native java.lang.reflect.Method getMethods0(int)[];
   */
  public static 
    void java_lang_Class_getMethods0(ReferenceVariable thisVar,
				     ReferenceVariable returnVar,
				     ReferenceVariable param0) {
    /* TODO */
  }

  /**
   * Returns a Constructor object that reflects the specified public
   * constructor of the class represented by this Class object.  The
   * parameterTypes parameter is an array of Class objects that
   * identify the constructor's formal parameter types, in declared
   * order.  
   * 
   *     private native java.lang.reflect.Constructor getConstructors0(int)[];
   */
  public static 
    void java_lang_Class_getConstructors0(ReferenceVariable thisVar,
					  ReferenceVariable returnVar,
					  ReferenceVariable param0) {
    /* TODO */
  }

  /**
   * Returns a Field object that reflects the specified public member
   * field of the class or interface represented by this Class object.
   *
   * Called by getField(String)
   *
   * NOTE: getField0(String name), since the name can be dynamically 
   *       constructed, it may be not able to know exact field name
   *       in static analysis. Uses a C.F to represent the class field.
   *
   *     private native java.lang.reflect.Field getField0(java.lang.String, 
   *                                                      int);       
   */
  public static 
    void java_lang_Class_getField0(ReferenceVariable thisVar,
				   ReferenceVariable returnVar,
				   ReferenceVariable param0,
				   ReferenceVariable param1) {
    /* TODO */
  }

  /**
   * Returns a Method object that reflects the specified public member
   * method of the class or interface represented by this Class
   * object.
   *
   * Called by getMethod()
   *
   *     private native java.lang.reflect.Method getMethod0(java.lang.String, 
   *                                                        java.lang.Class[],
   *                                                        int);
   */
  public static 
    void java_lang_Class_getMethod0(ReferenceVariable thisVar,
				    ReferenceVariable returnVar,
				    ReferenceVariable param0,
				    ReferenceVariable param1,
				    ReferenceVariable param2) {
    /* TODO */
  }

  /**
   * Returns a constructor of a class
   *
   *     private native java.lang.reflect.Constructor 
   *                            getConstructor0(java.lang.Class[], int);
   */
  public static
    void java_lang_Class_getConstructor0(ReferenceVariable thisVar,
					 ReferenceVariable returnVar,
					 ReferenceVariable param0,
					 ReferenceVariable param1) {
    /* TODO */
  }

  /**
   * Returns an array of Class objects reflecting all the classes and
   * interfaces declared as members of the class represented by this
   * Class object.
   *
   *     private native java.lang.Class getDeclaredClasses0()[];  
   */
  public static 
    void java_lang_Class_getDeclaredClasses0(ReferenceVariable thisVar,
					     ReferenceVariable returnVar) {
    /* TODO */
  }

  /**
   * Following methods have NO side effects.
   *
   * private static native void registerNatives();
   * public native boolean isInstance(java.lang.Object);
   * public native boolean isAssignableFrom(java.lang.Class);
   * public native boolean isInterface();
   * public native boolean isArray();
   * public native boolean isPrimitive();
   * public native int getModifiers();
   */

  /************************** java.lang.Package *************************/
  /**
   * This is an undocumented private native method, it returns the first
   * (without caller) method's package.
   *
   * It should be formulated as a string constants.
   * private static 
   *   native java.lang.String getSystemPackage0(java.lang.String);
   */
  public static 
    void java_lang_Package_getSystemPackage0(ReferenceVariable thisVar,
					     ReferenceVariable returnVar,
					     AbstractRefernece param0) {
    /* TODO */
  }

  /**
   * private static native java.lang.String getSystemPackages0()[];
   */
  public static 
    void java_lang_Package_getSystemPackages0(AbstractRefernece thisVar,
					      ReferenceVariable returnVar) {
    /* TODO */
  }

  /*************************** java.lang.Thread **********************/
  /**
   * Returns the single variable pointing to all thread objects.
   * 
   * This makes our analysis conservative on thread objects.
   *
   * public static native java.lang.Thread currentThread();
   */
  public static 
    void java_lang_Thread_currentThread(ReferenceVariable thisVar,
					ReferenceVariable returnVar){
    /* TODO */
  }

  /**
   * Following native methods have no side effects.
   *
   *    private static native void registerNatives(); 
   *    public static native void yield();
   *    public static native void sleep(long)
   *                     throws java.lang.InterruptedException;
   *    public native synchronized void start();
   *    private native boolean isInterrupted(boolean);
   *    public final native boolean isAlive();
   *    public native int countStackFrames();
   *    private native void setPriority0(int);
   *    private native void stop0(java.lang.Object);
   *    private native void suspend0();
   *    private native void resume0();
   *    private native void interrupt0();
   */

  /************************** java.lang.ClassLoader ******************/  
  /**
   * Converts an array of bytes into an instance of class
   * Class. Before the Class can be used it must be resolved.
   *
   * NOTE: an object representing an class object.
   *       To be conservative, the side-effect of this method will
   *       return an abstract reference points to all possible class object
   *       in current analysis environment.
   *
   * private native 
   *   java.lang.Class defineClass0(java.lang.String, 
   *                                byte[], 
   *                                int, 
   *                                int, 
   *                                java.security.ProtectionDomain);
   */
  public static 
    void java_lang_ClassLoader_defineClass0(ReferenceVariable thisVar,
					    ReferenceVariable returnVar,
					    ReferenceVariable param0,
					    ReferenceVariable param1,
					    ReferenceVariable param2,
					    ReferenceVariable param3,
					    ReferenceVariable param4) {
    /* TODO */
  }

  /**
   * NOTE: undocumented, finding the bootstrap class
   * 
   * Assuming all classes
   *
   * private native 
   *   java.lang.Class findBootstrapClass(java.lang.String) 
   *                   throws java.lang.ClassNotFoundException;
   */
  public static 
    void java_lang_ClassLoader_findBootstrapClass(
                                         ReferenceVariable thisVar,
					 ReferenceVariable returnVar,
					 AbstractReferenct param0) {
    /* TODO */
  }

  /**
   * Finds the class with the given name if it had been previously
   * loaded through this class loader.
   * 
   * NOTE: assuming all classes.
   *
   * protected final native java.lang.Class findLoadedClass(java.lang.String);
   */
  public static 
    void java_lang_ClassLoader_findLoadedClass(ReferenceVariable thisVar,
					       ReferenceVariable returnVar,
					       ReferenceVariable param0) {
    /* TODO */
  }

  /**
   * Returns a variable pointing to the only class loader
   *
   * static native java.lang.ClassLoader getCallerClassLoader();
   */
  public static 
    void java_lang_ClassLoader_getCallerClassLoader(
				    ReferenceVariable thisVar,
				    ReferenceVariable returnVar) {
    /* TODO */
  }

  /**
   * NO side effects.
   *
   * Assuming that resolving a class has not effect on the class load
   * and class object
   *
   *    private native void resolveClass0(java.lang.Class);
   */

  /************** java.lang.ClassLoader$NativeLibrary ****************/
  /**
   * NO side effects
   *
   *        native void load(java.lang.String);
   *        native long find(java.lang.String);
   *        native void unload();
   */

  /************************* java.lang.SecurityManager ***************/
  /**
   * Returns the current execution stack as an array of classes. 
   *
   * NOTE: an array of object may be created.
   * 
   *     protected native java.lang.Class getClassContext()[];
   */
  public static 
    void java_lang_SecurityManager_getClassContext(ReferenceVariable thisVar,
						   ReferenceVariable returnVar){
    /* TODO */
  }

  /**
   * Returns the class loader of the most recently executing method
   * from a class defined using a non-system class loader. A
   * non-system class loader is defined as being a class loader that
   * is not equal to the system class loader (as returned by
   * ClassLoader.getSystemClassLoader()) or one of its ancestors.
   *
   * NOTE: returns a variable pointing to the only class loader object. 
   *
   *     private native java.lang.ClassLoader currentClassLoader0();
   */
  public static 
    void java_lang_SecurityManager_currentClassLoader0(
			    ReferenceVariable thisVar,
			    ReferenceVariable returnVar) {
    /* TODO */
  }

  /**
   * Returns a variable pointing to all class objects.
   * 
   *    private native java.lang.Class currentLoadedClass0();
   */
  public static 
    void java_lang_SecurityManager_currentLoadedClass0(
					 ReferenceVariable thisVar,
					 ReferenceVariable returnVar) {
    /* TODO */
  }

  /**
   * Both methods have NO side effects.
   *
   *     protected native int classDepth(java.lang.String);
   *     private native int classLoaderDepth0(); 
   */

  /************************ java.io.FileInputStream *****************/
  /**
   * Following methods have NO side effects.
   *
   *    private native void open(java.lang.String) 
   *                  throws java.io.FileNotFoundException;
   *    public native int read() throws java.io.IOException;
   *    private native int readBytes(byte[], int, int) 
   *                        throws java.io.IOException;
   *    public native int available() throws java.io.IOException;
   *    public native void close() throws java.io.IOException;
   *    private static native void initIDs();
   */
				       
  /*********************** java.io.FileOutputStream *****************/
  /**
   * NO side effects, may throw exceptions.
   *
   *    private native void open(java.lang.String) 
   *                    throws java.io.FileNotFoundException;
   *    private native void openAppend(java.lang.String) 
   *                    throws java.io.FileNotFoundException;
   *    public native void write(int) 
   *                    throws java.io.IOException;
   *    private native void writeBytes(byte[], int, int) 
   *                    throws java.io.IOException;
   *    public native void close() 
   *                    throws java.io.IOException;
   *    private static native void initIDs();
   */

  /*********************** java.io.ObjectInputStream *******************/
  /**
   * NOTE: conservatively returns a reference pointing to the only copy 
   * of the class loader.
   *
   * private static native java.lang.ClassLoader latestUserDefinedLoader() 
   *                        throws java.lang.ClassNotFoundException;
   */
  public static 
    void java_io_ObjectInputStream_latestUserDefinedLoader(
					ReferenceVariable thisVar,
					ReferenceVariable returnVar){
    /* TODO */
  }

  /**
   * Serialization has to be avoided by static analyses, since each
   * object comes out of the same place.
   *
   * NOTE: undocumented methods, but I can guess both allocate objects
   *       or array from GC, treat them as a instance or new site
   */

  /** 
   *
   * private static native java.lang.Object allocateNewObject(java.lang.Class,
   *                                                          java.lang.Class)
   *                             throws java.lang.InstantiationException, 
   *                             java.lang.IllegalAccessException;
   */
  public static 
    void java_io_ObjectInputStream_allocateNewObject(
                                                 ReferenceVariable thisVar,
						 ReferenceVariable returnVar,
						 ReferenceVariable param0,
						 ReferenceVariable param1){
    /* TODO */
  }
  /**
   * private static native java.lang.Object allocateNewArray(java.lang.Class, 
   *                                                         int);
   */
  public static 
    void java_io_ObjectInputStream_allocateNewArray(
                                                 ReferenceVariable thisVar,
						 ReferenceVariable returnVar,
						 ReferenceVariable param0,
						 ReferenceVariable param1){
    /* TODO */
  }

  /**
   * Following methods have NO side effect, (the last one?????)
   * to be verified with serialization and de-serialization.
   * 
   * private static native void bytesToFloats(byte[], int, float[], int, int);
   * private static native void bytesToDoubles(byte[], int, 
   *                                           double[], int, int);
   * private static native void setPrimitiveFieldValues(java.lang.Object, 
   *                                                    long[], 
   *                                                    char[], 
   *                                                    byte[]);
   * private static native void setObjectFieldValue(java.lang.Object, 
   *                                                long, 
   *                                                java.lang.Class, 
   *                                                java.lang.Object);
   */

  /******************* java.io.ObjectOutputStream *******************/

  /**
   * Following three native methods have no side effects.
   *
   * private static native void floatsToBytes(float[], int, byte[], int, int);
   * private static native void doublesToBytes(double[], int, 
   *                                           byte[], int, int);
   * private static native void getPrimitiveFieldValues(java.lang.Object, 
   *                                                    long[], 
   *                                                    char[], 
   *                                                    byte[]);
   * @see default(...)
   */
  

  /**
   * The object in field is retrieved out by field ID.
   * A conservative approach would be all objects possibly pointed by
   * @param0's fields can be returned.
   *
   * NOTE: 
   *
   * private static native 
   *         java.lang.Object getObjectFieldValue(java.lang.Object, long);
   */
  public static 
    void java_io_ObjectOutputStream_getObjectFieldValue(
				    ReferenceVariable thisVar,
				    ReferenceVariable returnVar,
				    ReferenceVariable param0,
				    ReferenceVariable param1) {
    /* TODO */
  }

  /*************************** java.io.ObjectStreamClass ******************/
  /**
   * NO side effects.
   *
   * private static native void initNative();
   * private static native void getFieldIDs(java.io.ObjectStreamField[], 
   *                                        long[], long[]);
   * private static native boolean hasStaticInitializer(java.lang.Class);
   */

  /************************ java.io.FileSystem ***********************/
  /**
   * Returns a variable pointing to the file system constant
   *
   *    public static native java.io.FileSystem getFileSystem();
   */
  public static 
    void java_io_FileSystem_getFileSystem(ReferenceVariable thisVar,
					  ReferenceVariable returnVar) {
    /* TODO */
  }

  /*********************** java.io.FileDescriptor *********************/
  /**
   * Both methods have no side effects.
   *
   *    public native void sync() throws java.io.SyncFailedException;
   *    private static native void initIDs();
   *
   * @see _default(...)
   */

  /*********************** java.lang.reflect.Field *********************/
  /**
   * Returns the value of the field represented by this Field, on the
   * specified object. The value is automatically wrapped in an object
   * if it has a primitive type.
   *
   * NOTE: this really needs precise info of @this (its name).
   *       conservative way, makes return value possibly point
   *       to universal objects. 
   *
   *  public native java.lang.Object get(java.lang.Object) 
   *                throws java.lang.IllegalArgumentException, 
   *                       java.lang.IllegalAccessException;
   */
  public static 
    void java_lang_reflect_Field_get(ReferenceVariable thisVar,
				     ReferenceVariable returnVar,
				     ReferenceVariable param0){
    /* TODO */
  }
  
  /**
   * NOTE: make all fields pointing to @param1
   *
   *     public native void set(java.lang.Object, java.lang.Object) 
   *                   throws java.lang.IllegalArgumentException, 
   *                          java.lang.IllegalAccessException;
   */
  public static 
    void java_lang_reflect_Field_set(ReferenceVariable thisVar,
				     ReferenceVariable returnVar,
				     ReferenceVariable param0,
				     ReferenceVariable param1) {
    /* TODO */
  }

  /**
   * All other native methods in this class has no side effects.
   *
   * public native boolean getBoolean(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native byte getByte(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   * 
   * public native char getChar(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native short getShort(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native int getInt(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *     
   * public native long getLong(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native float getFloat(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native double getDouble(java.lang.Object) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native void setBoolean(java.lang.Object, boolean) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native void setByte(java.lang.Object, byte) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   * 
   * public native void setChar(java.lang.Object, char) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native void setShort(java.lang.Object, short) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *   
   * public native void setInt(java.lang.Object, int) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native void setLong(java.lang.Object, long) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native void setFloat(java.lang.Object, float) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * public native void setDouble(java.lang.Object, double) 
   *                       throws java.lang.IllegalArgumentException, 
   *                              java.lang.IllegalAccessException;
   *
   * @see default(...)
   */

  /************ java.lang.reflect.Array **********************/
  /**
   * Returns the value of the indexed component in the specified array
   * object. The value is automatically wrapped in an object if it has
   * a primitive type.
   *
   * NOTE: @return = @param0[]
   *
   * public static native java.lang.Object get(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   */
  public static 
    void java_lang_reflect_Array_get(ReferenceVariable thisVar,
				     ReferenceVariable returnVar,
				     ReferenceVariable param0,
				     ReferenceVariable param1) {
    /* TODO */
  }
  
  /**
   * @param0[] = @param1
   *
   * public static native void set(java.lang.Object, int, java.lang.Object) 
   *                         throws java.lang.IllegalArgumentException, 
   *                                java.lang.ArrayIndexOutOfBoundsException;
   */
  public static 
    void java_lang_reflect_Array_set(ReferenceVariable thisVar,
				     ReferenceVariable returnVar,
				     ReferenceVariable param0,
				     ReferenceVariable param1,
				     ReferenceVariable param2) {
    /* TODO */			
  }

  /**
   * Treat this method as
   * @return = new A[];
   *
   * private static native java.lang.Object newArray(java.lang.Class, int) 
   *                        throws java.lang.NegativeArraySizeException;
   */
  public static 
    void java_lang_reflect_Array_newArray(ReferenceVariable thisVar,
					  ReferenceVariable returnVar,
					  ReferenceVariable param0,
					  ReferenceVariable param1){
    /* TODO */
  }

  /**
   * Treat this method as
   * @return = new A[][];
   *
   * private static native java.lang.Object multiNewArray(java.lang.Class, 
   *                                                      int[]) 
   *                        throws java.lang.IllegalArgumentException, 
   *                               java.lang.NegativeArraySizeException;
   */
  public static 
    void java_lang_reflect_Array_multiNewArray(ReferenceVariable thisVar,
					       ReferenceVariable returnVar,
					       ReferenceVariable param0,
					       ReferenceVariable param1){
    /* TODO */
  }

  /**
   * Following native methods have no side effects.
   *    
   * public static native int getLength(java.lang.Object) 
   *                     throws java.lang.IllegalArgumentException;
   *
   * public static native boolean getBoolean(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native byte getByte(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   * 
   * public static native char getChar(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *                
   * public static native short getShort(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native int getInt(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native long getLong(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native float getFloat(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   * 		                java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native double getDouble(java.lang.Object, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *           		        java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setBoolean(java.lang.Object, int, boolean) 
   *                     throws java.lang.IllegalArgumentException, 
   *	            	        java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setByte(java.lang.Object, int, byte) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setChar(java.lang.Object, int, char) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setShort(java.lang.Object, int, short) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setInt(java.lang.Object, int, int) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setLong(java.lang.Object, int, long) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setFloat(java.lang.Object, int, float) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   *
   * public static native void setDouble(java.lang.Object, int, double) 
   *                     throws java.lang.IllegalArgumentException, 
   *                            java.lang.ArrayIndexOutOfBoundsException;
   * @see default(...)
   */

  /****************** java.lang.reflect.Method *********************/
  /**
   * nvokes the underlying method represented by this Method object,
   * on the specified object with the specified parameters.
   * Individual parameters are automatically unwrapped to match
   * primitive formal parameters, and both primitive and reference
   * parameters are subject to widening conversions as necessary. The
   * value returned by the underlying method is automatically wrapped
   * in an object if it has a primitive type.
   *
   * Method invocation proceeds with the following steps, in order: 
   *
   * If the underlying method is static, then the specified obj
   * argument is ignored. It may be null.  
   *
   * NOTE: @this is an variable pointing to method objects,
   *       @param0 points to receivers
   * 
   *       The possible target of this call is made by 
   *       [thisVar] X [param0]
   * 
   *       Also the parameters are not distinguishable.
   *
   * public native java.lang.Object invoke(java.lang.Object, 
   *                                       java.lang.Object[]) 
   *                    throws java.lang.IllegalAccessException, 
   *                           java.lang.IllegalArgumentException, 
   *                           java.lang.reflect.InvocationTargetException
   */
  public static 
    void java_lang_reflect_Method_invoke(ReferenceVariable thisVar,
					 ReferenceVariable returnVar,
					 ReferenceVariable param0,
					 ReferenceVariable param1) {
    /* TODO */
  }


  /********************** java.lang.reflect.Constructor ****************/
  /**
   * Uses the constructor represented by this Constructor object to
   * create and initialize a new instance of the constructor's
   * declaring class, with the specified initialization
   * parameters. Individual parameters are automatically unwrapped to
   * match primitive formal parameters, and both primitive and
   * reference parameters are subject to method invocation conversions
   * as necessary. Returns the newly created and initialized object.  
   *
   * NOTE: @return = new Object; but we lose type information.
   *
   * public native java.lang.Object newInstance(java.lang.Object[]) 
   *                throws java.lang.InstantiationException, 
   *                       java.lang.IllegalAccessException, 
   *                       java.lang.IllegalArgumentException, 
   *                       java.lang.reflect.InvocationTargetException;
   */
  public static 
    void java_lang_reflect_Constructor_newInstance(ReferenceVariable thisVar,
						   ReferenceVariable returnVar,
						   ReferenceVariable param0){
    /* TODO */
  }

  /*********  java.lang.reflect.Proxy *********************/
  /**
   * We have to assume all possible classes will be returned.
   * But it is still possible to make a new class.
   *
   * NOTE: assuming a close world, and this method should not
   *       be called.
   *
   * private static native java.lang.Class defineClass0(java.lang.ClassLoader, 
   *                                                    java.lang.String, 
   *                                                    byte[], int, int);
   */
  public static 
    void java_lang_reflect_Proxy_defineClass0(ReferenceVariable thisVar,
					      ReferenceVariable returnVar,
					      ReferenceVariable param0,
					      ReferenceVariable param1,
					      ReferenceVariable param2,
					      ReferenceVariable param3,
					      ReferenceVariable param5) {
    /* TODO */
  }

  /********** java.util.ResourceBundle ******************/
  /**
   * Undocumented, returns an array of all possible classes.
   * NOTE: @return = new Class[];
   *       @return[] = { all classes }
   *
   *     private static native java.lang.Class getClassContext()[];
   */
  public static 
    void java_util_ResrouceBundle_getClassContext(ReferenceVariable thisVar,
						  ReferenceVariable returnVar){
    /* TODO */
  }

  /*********************** java.util.TimeZone **********************/
  /**
   * It should return a constant for TimeZone
   *
   * Gets the TimeZone for the given ID.
   *
   * private static native 
   *   java.lang.String getSystemTimeZoneID(java.lang.String, 
   *                                        java.lang.String);
   */
  public static 
    void java_util_TimeZone_getSystemTimeZoneID(ReferenceVariable thisVar,
						ReferenceVariable returnVar,
						ReferenceVariable param0,
						ReferenceVariable param1) {
    /* TODO */
  }

  /*********************** java.util.zip.CRC32 *********************/
  /**
   * NO side effects.
   *
   *    private static native int update(int, int);
   *    private static native int updateBytes(int, byte[], int, int);
   *
   * @see default(...)
   */

  /*********************** java.util.zip.Inflater ******************/
  /**
   * All methods should have no side effects.
   * 
   *    private static native void initIDs();
   *    private static native long init(boolean);
   *    private static native void setDictionary(long, byte[], int, int);
   *    private native int inflateBytes(byte[], int, int) 
   *                     throws java.util.zip.DataFormatException;
   *    private static native int getAdler(long);
   *    private static native int getTotalIn(long);
   *    private static native int getTotalOut(long);
   *    private static native void reset(long);
   *    private static native void end(long);
   * 
   * @see default(...)
   */

  /*********************** java.util.zip.JarFile ******************/
  /**
   * The methods returns an array of strings.
   * 
   * @return = new String[]
   *
   *     private native java.lang.String getMetaInfEntryNames()[];
   */
  public static 
    void java_util_zip_JarFile_getMetaInfoEntryNames(
                                        ReferenceVariable thisVar,
					ReferenceVariable returnVar) {
    /* TODO */
  }

  /*********************** java.util.zip.ZipFile ******************/
  /**
   * Following methods have no side effect on objects.
   *    private static native void initIDs()
   *    private static native long open(java.lang.String, int);
   *    private static native int getTotal(long);
   *    private static native long getEntry(long, java.lang.String);
   *    private static native void freeEntry(long, long);
   *    private static native int getMethod(long);
   *    private static native long getNextEntry(long, int);
   *    private static native void close(long);
   *    private static native int read(long, long, int, byte[], int, int);
   *    private static native int getCSize(long);
   *    private static native int getSize(long);
   *
   * @see default(...)
   */

  /************************ java.util.zip.ZipEntry ********************/
  /**
   * Methods have no side effects.
   *
   *    private static native void initIDs();
   *    private native void initFields(long);
   */   
 
  /************************ java.security.AccessController ************/

  /* I am not sure how doPrivileged acts, the general effect is that
   * it returns what action.run() returns.
   * 
   * A conservative solution is to connect the return value of run method of
   * all classes which implement PrivilegedAction, PrivilegeExceptionAction
   *  interface to this return value.
   */

  /**
   * NOTE: these two method has the same name and the same number of 
   *       parameters. They will share one simulating method.
   * 
   * public static native 
   *   java.lang.Object doPrivileged(java.security.PrivilegedAction);
   *
   * public static native 
   *   java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction) 
   *                    throws java.security.PrivilegedActionException;
   */
  public static
    void java_security_AccessController_doPrivileged(
				 ReferenceVariable thisVar,
				 ReferenceVariable returnVar,
				 ReferenceVariable param0) {
    /* TODO */
  }
  
  /**
   * NOTE: these two method has the same name and the same number of 
   *       parameters. They will share one simulating method.
   * 
   * public static native 
   *   java.lang.Object doPrivileged(java.security.PrivilegedAction, 
   *                                  java.security.AccessControlContext);
   *
   * public static native 
   *   java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction, 
   *                                 java.security.AccessControlContext) 
   *                    throws java.security.PrivilegedActionException;
   */
  public static
    void java_security_AccessController_doPrivileged(
				 ReferenceVariable thisVar,
				 ReferenceVariable returnVar,
				 ReferenceVariable param0,
				 ReferenceVariable param1) {
    /* TODO */
  }

  /**
   * Creates an access control context object.
   *
   * private static native 
   *   java.security.AccessControlContext getStackAccessControlContext();
   */
  public static 
    void java_security_AccessController_getStackAccessControlContext(
					    ReferenceVariable thisVar,
					    ReferenceVariable returnVar){
    /* TODO */
  }


  /**
   * NOTE: not documented and not called by anyone
   *
   * static native 
   *   java.security.AccessControlContext getInheritedAccessControlContext();
   */
  public static
    void java_security_AccessController_getInheritedAccessControlContext(
					   ReferenceVariable thisVar,
					   ReferenceVariable returnVar){
    /* TODO */
  }

  /************************ java.net.InetAddress *********************/
  /**
   * NO side effects.
   *
   *     private static native void init();
   */

  /************************ java.net.InetAddressImpl *****************/
  /**
   * Returns a variable pointing to a string constant
   *
   * I am not sure if repeated calls of methods in this class will
   * return the same object or not. A conservative approach would
   * say YES, for definitely points-to, but NO for may points-to.
   *
   * We should avoid analyzing these unsafe native methods.
   *
   *     native java.lang.String getLocalHostName() 
   *                      throws java.net.UnknownHostException;
   */
  public static 
    void java_net_InetAddressImpl_getLocalHostName(
                                          ReferenceVariable thisVar,
					  ReferenceVariable returnVar){
    /* TODO */
  }
  
  /**
   * Create a string object
   *
   *     native java.lang.String getHostByAddr(int) 
   *                     throws java.net.UnknownHostException;
   */
  public static 
    void java_net_InetAddressImpl_getHostByAddr(ReferenceVariable thisVar,
						ReferenceVariable returnVar,
						ReferenceVariable param0) {
    /* TODO */
  }

  /**
   * NO side effects.
   *    native void makeAnyLocalAddress(java.net.InetAddress);
   *    native byte lookupAllHostAddr(java.lang.String)[][] 
   *                     throws java.net.UnknownHostException;
   *    native int getInetFamily();
   *
   * @see default(...)
   */

  /*********************** sun.misc.Signal ***********************/
  /**
   * Following methods have no side effects.
   *
   *    private static native int findSignal(java.lang.String);
   *    private static native long handle0(int, long);
   *    private static native void raise0(int);
   */

  /*********************** sun.misc.NativeSignalHandler **********/
  /**
   * NO side effects.
   *     private final long handler;
   */

  /************** DEFAULT native methods *************************/
  public static void _default(ReferenceVariable thisVar,
			      ReferenceVariable returnVar,
			      ReferenceVariable[] params){
    /* Do nothing, give debugging or warning information. */
  }
