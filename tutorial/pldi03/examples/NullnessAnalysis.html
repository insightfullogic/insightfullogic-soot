<HTML> <HEAD> <TITLE>NullnessAnalysis.java</TITLE> </HEAD> <BODY> <PRE> 
<FONT COLOR=Purple>import</FONT> <FONT COLOR=CadetBlue>soot</FONT>.<FONT COLOR=CadetBlue>*</FONT>;
<FONT COLOR=Purple>import</FONT> <FONT COLOR=CadetBlue>soot</FONT>.<FONT COLOR=CadetBlue>jimple</FONT>.<FONT COLOR=CadetBlue>*</FONT>;
<FONT COLOR=Purple>import</FONT> <FONT COLOR=CadetBlue>soot</FONT>.<FONT COLOR=CadetBlue>toolkits</FONT>.<FONT COLOR=CadetBlue>scalar</FONT>.<FONT COLOR=CadetBlue>*</FONT>;
<FONT COLOR=Purple>import</FONT> <FONT COLOR=CadetBlue>soot</FONT>.<FONT COLOR=CadetBlue>toolkits</FONT>.<FONT COLOR=CadetBlue>graph</FONT>.<FONT COLOR=CadetBlue>*</FONT>;
<FONT COLOR=Purple>import</FONT> <FONT COLOR=CadetBlue>soot</FONT>.<FONT COLOR=CadetBlue>util</FONT>.<FONT COLOR=CadetBlue>*</FONT>;

<FONT COLOR=Purple>import</FONT> <FONT COLOR=CadetBlue>java</FONT>.<FONT COLOR=CadetBlue>util</FONT>.<FONT COLOR=CadetBlue>*</FONT>;

<FONT COLOR=Firebrick>/** Tracks which locals are definitely non-null.
 * Based on BranchedRefVarsAnalysis by Janus Godard (janus@place.org). */</FONT>
<FONT COLOR=Purple>class</FONT> <FONT COLOR=ForestGreen>NullnessAnalysis</FONT> <FONT COLOR=Purple>extends</FONT> <FONT COLOR=ForestGreen>ForwardBranchedFlowAnalysis</FONT>
{
    <FONT COLOR=Purple>protected</FONT> <FONT COLOR=ForestGreen>void</FONT> <FONT COLOR=Blue>copy</FONT>(<FONT COLOR=ForestGreen>Object</FONT> <FONT COLOR=DarkGoldenrod>src</FONT>, 
                        <FONT COLOR=ForestGreen>Object</FONT> <FONT COLOR=DarkGoldenrod>dest</FONT>) {
        <FONT COLOR=ForestGreen>FlowSet</FONT> <FONT COLOR=DarkGoldenrod>sourceSet</FONT> = (<FONT COLOR=ForestGreen>FlowSet</FONT>)src,
            destSet = (<FONT COLOR=ForestGreen>FlowSet</FONT>) dest;
        
        sourceSet.copy(destSet);
    }


    <FONT COLOR=Purple>protected</FONT> <FONT COLOR=ForestGreen>void</FONT> <FONT COLOR=Blue>merge</FONT>(<FONT COLOR=ForestGreen>Object</FONT> <FONT COLOR=DarkGoldenrod>src1</FONT>, <FONT COLOR=ForestGreen>Object</FONT> <FONT COLOR=DarkGoldenrod>src2</FONT>, <FONT COLOR=ForestGreen>Object</FONT> <FONT COLOR=DarkGoldenrod>dest</FONT>)
    {
        <FONT COLOR=ForestGreen>FlowSet</FONT> <FONT COLOR=DarkGoldenrod>srcSet1</FONT> = (<FONT COLOR=ForestGreen>FlowSet</FONT>) src1;
        <FONT COLOR=ForestGreen>FlowSet</FONT> <FONT COLOR=DarkGoldenrod>srcSet2</FONT> = (<FONT COLOR=ForestGreen>FlowSet</FONT>) src2;
        <FONT COLOR=ForestGreen>FlowSet</FONT> <FONT COLOR=DarkGoldenrod>destSet</FONT> = (<FONT COLOR=ForestGreen>FlowSet</FONT>) dest;

        srcSet1.intersection(srcSet2, destSet);
    }

    <FONT COLOR=ForestGreen>FlowSet</FONT> <FONT COLOR=DarkGoldenrod>fullSet</FONT>, <FONT COLOR=DarkGoldenrod>emptySet</FONT>;
    <FONT COLOR=ForestGreen>FlowUniverse</FONT> <FONT COLOR=DarkGoldenrod>allRefLocals</FONT>;
    <FONT COLOR=ForestGreen>Map</FONT> <FONT COLOR=DarkGoldenrod>unitToGenerateSet</FONT>;

    <FONT COLOR=Purple>protected</FONT> <FONT COLOR=ForestGreen>void</FONT> <FONT COLOR=Blue>flowThrough</FONT>(<FONT COLOR=ForestGreen>Object</FONT> <FONT COLOR=DarkGoldenrod>srcValue</FONT>, <FONT COLOR=ForestGreen>Unit</FONT> <FONT COLOR=DarkGoldenrod>unit</FONT>,
                               <FONT COLOR=ForestGreen>List</FONT> <FONT COLOR=DarkGoldenrod>fallOut</FONT>, <FONT COLOR=ForestGreen>List</FONT> <FONT COLOR=DarkGoldenrod>branchOuts</FONT>)
    {
        FlowSet dest;
        FlowSet src  = (FlowSet) srcValue;
        Unit    s    = (Unit)    unit;

        // Create working set.
        dest = (FlowSet)src.clone();

        // Take out kill set.
        Iterator boxIt = s.getDefBoxes().iterator();
        while (boxIt.hasNext()) {
            ValueBox box = (ValueBox) boxIt.next();
            Value value = box.getValue();
            if (value instanceof Local &amp;&amp; 
                    isRefOrArrayType(value.getType()))
                dest.remove(value);
        }

        // Perform gen.
        dest.union((FlowSet)unitToGenerateSet.get(unit), dest);

        // Handle copy statements: 
        //    x = y &amp;&amp; 'y' in src =&gt; add 'x' to dest
        if (s instanceof DefinitionStmt)
        {
            DefinitionStmt as = (DefinitionStmt) s;

            Value ro = as.getRightOp();

            // extract cast argument
            if (ro instanceof CastExpr)
                ro = ((CastExpr) ro).getOp();
        
            if (src.contains(ro) &amp;&amp;
                  as.getLeftOp() instanceof Local)
                dest.add(as.getLeftOp());
        }

        // Copy the out value to all branch boxes.
        {
            Iterator it = fallOut.iterator();
            while (it.hasNext()) {
                FlowSet fs = (FlowSet) (it.next());
                copy(dest, fs);
            }
        }
        
        // Copy the out value to the fallthrough box (don't need iterator)
        {
            Iterator it = branchOuts.iterator();
            while (it.hasNext()) {
                FlowSet fs = (FlowSet) (it.next());
                copy(dest, fs);
            }
        }

        // Handle if statements by patching dest sets.
        if (unit instanceof IfStmt)
        {
            Value cond = ((IfStmt)unit).getCondition();
            Value op1 = ((BinopExpr) cond).getOp1();
            Value op2 = ((BinopExpr) cond).getOp2();
            boolean isNeg = cond instanceof NeExpr;
            Value toGen = null;

            // case 1: opN is a local and opM is NullConstant
            //          =&gt; opN nonnull on ne branch.
            if (op1 instanceof Local &amp;&amp; op2 instanceof NullConstant)
                toGen = op1;

            if (op2 instanceof Local &amp;&amp; op1 instanceof NullConstant)
                toGen = op2;

            if (toGen != null)
            {
                Iterator it = null;

                // if (toGen != null) goto l1: on branch, toGen nonnull.
                if (isNeg)
                    it = branchOuts.iterator();
                else
                    it = fallOut.iterator();

                while(it.hasNext()) {
                    FlowSet fs = (FlowSet) (it.next());
                    fs.add(toGen);
                }
            }

            // case 2: both ops are local and one op is non-null and testing equality
            if (op1 instanceof Local &amp;&amp; op2 instanceof Local &amp;&amp; 
                cond instanceof EqExpr)
            {
                toGen = null;

                if (src.contains(op1))
                    toGen = op2;
                if (src.contains(op2))
                    toGen = op1;

                if (toGen != null)
                {
                    Iterator branchIt = branchOuts.iterator();
                    while (branchIt.hasNext()) {
                        FlowSet fs = (FlowSet) (branchIt.next());
                        fs.add(toGen);
                    }
                }
            }    
        }
    }

    protected Object newInitialFlow()
    {
        return fullSet.clone();
    }

    protected Object entryInitialFlow()
    {
        // everything could be null
        return emptySet.clone();
    }

    private void addGen(Unit u, Value v)
    {
        ArraySparseSet l = (ArraySparseSet)unitToGenerateSet.get(u);
        l.add(v);
    }

    private void addGensFor(DefinitionStmt u)
    {
        Value lo = u.getLeftOp();
        Value ro = u.getRightOp();

        if (ro instanceof NewExpr ||
             ro instanceof NewArrayExpr ||
             ro instanceof NewMultiArrayExpr ||
             ro instanceof ThisRef ||
             ro instanceof CaughtExceptionRef)
            addGen(u, lo);
    }

    public NullnessAnalysis(UnitGraph g)
    {
        super(g);

        unitToGenerateSet = new HashMap();

        Body b = g.getBody();

        List refLocals = new LinkedList();

        // set up universe, empty, full sets.

        emptySet = new ArraySparseSet();
        fullSet = new ArraySparseSet();

        // Find all locals in body.
        Iterator localIt = b.getLocals().iterator();
        while (localIt.hasNext())
        {
            Local l = (Local)localIt.next();
            if (isRefOrArrayType(l.getType()))
                fullSet.add(l);
        }

        // Create gen sets.
        Iterator unitIt = b.getUnits().iterator();
        while (unitIt.hasNext())
        {
            Unit u = (Unit)unitIt.next();
            unitToGenerateSet.put(u, new ArraySparseSet());

            if (u instanceof DefinitionStmt)
            {
                Value lo = ((DefinitionStmt)u).getLeftOp();
                if (lo instanceof Local &amp;&amp; 
                       isRefOrArrayType(lo.getType()))
                    addGensFor((DefinitionStmt)u);
            }

            Iterator boxIt = u.getUseAndDefBoxes().iterator();
            while (boxIt.hasNext())
            {
                Value boxValue = ((ValueBox) boxIt.next()).getValue();
                Value base = null;
                    
                if(boxValue instanceof InstanceFieldRef) {
                    base = ((InstanceFieldRef) (boxValue)).getBase();
                } else if (boxValue instanceof ArrayRef) {
                    base = ((ArrayRef) (boxValue)).getBase();
                } else if (boxValue instanceof InstanceInvokeExpr) {
                    base = ((InstanceInvokeExpr) boxValue).getBase();
                } else if (boxValue instanceof LengthExpr) {
                    base = ((LengthExpr) boxValue).getOp();
                } else if (u instanceof ThrowStmt) {
                    base = ((ThrowStmt)u).getOp();
                } else if (u instanceof MonitorStmt) {
                    base = ((MonitorStmt)u).getOp();
                }

                if (base != null &amp;&amp; 
                      base instanceof Local &amp;&amp; 
                      isRefOrArrayType(base.getType()))
                    addGen(u, base);
            }
        }

        // Call superclass method to do work.
        doAnalysis();
    }

    private boolean isRefOrArrayType(Type t)
    {
        return t instanceof RefType || t instanceof ArrayType;
    }
}

</PRE> </BODY> </HTML>