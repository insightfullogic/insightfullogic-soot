\begin{slide}{Flow Analysis in Soot}
Will describe how to implement a flow analysis in Soot and present examples:
\begin{itemize}
\item live locals
\item branched nullness testing
\end{itemize}
\end{slide}

\begin{slide}{Running Example: Live Variables}
\vspace*{-0.2in}
For a statement $s$, want to know which local variables
are {\green live} at $s$.

A local variable {\tt v} is live at $s$ if there exists some statement
$s'$ using {\tt v} and a control-flow path from $s$ to $s'$.

\begin{center}
%\input{rd-example.eepic}
\end{center}
\end{slide}

\begin{slide}{Six Steps to Flow Analysis}
\begin{enumerate}
\item Decide what you are approximating,\\ partial order for approximation domain.

\item State the problem precisely.

\item Forward or backward?

\item Decide on a confluence operator.

\item Write equation for each kind of IR statement.

\item State the starting approximation.
\end{enumerate}
\end{slide}

% slide: abstraction domain

\begin{slide}{Step 1b: Abstraction Implementation}
Need to implement {\tt copy()}, {\tt merge()} methods:
\begin{center}
\input{copy.eepic}
\end{center}
{\tt copy()} brings OUT set to successor's IN set.

$\qquad$

\begin{center}
\input{merge.eepic}
\end{center}
{\tt merge()} joins two OUT sets to make an IN set.
\end{slide}

\begin{slide}{Step 1b: Abstraction Implementation}
Signatures:
{\small 
\[ \mbox{\tt \begin{tabular}{r@{}l}
                 void merge(&Object in1, Object in2,\\
                            &Object out);\\
                 void copy(&Object src, Object dest);
\end{tabular}}\]
}

We delegate implementation to {\tt FlowSet}.
\end{slide}

\begin{slide}{Step 1b': {\tt copy()} for live variables}
\begin{verbatim}
protected void copy(Object src, 
                    Object dest) {
  FlowSet sourceSet = (FlowSet)src,
      destSet = (FlowSet) dest;

\end{verbatim}    
{\red\verb+  sourceSet.copy(destSet);+}
\begin{verbatim}
}
\end{verbatim}

\qquad

Use {\tt FlowSet}'s implementation of {\tt copy()}.

\qquad

We'll do {\tt merge()} later.
\end{slide}

% step 2: problem statement

\begin{slide}{Step 3: Forward or Backward?}

Live variables is a backward flow analysis, since flow
f$^{\mbox{\scriptsize n}}$ computes {\sf IN} sets from {\sf OUT} sets.

\qquad

In Soot, we subclass {\tt \red BackwardFlowAnalysis}.

\qquad

{\red \tt class LiveVariablesAnalysis \\ \qquad extends ForwardFlowAnalysis}
\end{slide}

\begin{slide}{Step 4: Join operator}
In live variables, a variable {\tt v} is live if there exists any path
from {\tt d} to {\tt p}, so we use union.

\qquad

Like {\tt copy()}, use {\tt FlowSet}'s {\tt union}:

\vspace*{0.05in}

\begin{verbatim}
  void merge(...) {
    // [cast Objects to FlowSets]
\end{verbatim}
{\red\verb+    inSet1.union(inSet2, outSet);+}\\
\verb+  }+

\vspace*{0.1in}

Could also use {\tt intersection()}, or implement a more exotic merge.

\end{slide}

\begin{slide}{Step 5: Flow equations}
\vspace*{-0.1in}

Goal: At a def'n stmt {\tt x = y + z}, remove {\tt x} from the
flow set and add {\tt y} and {\tt z}.

\vspace*{0.1in}

Must implement this method:
\begin{verbatim}
    protected void flowThrough
                 (Object inValue, 
                  Object u, 
                  Object outValue)
\end{verbatim}

We start by:
\begin{itemize}
\item casting {\tt inValue}, {\tt outValue} to {\tt FlowSet}.

\item casting {\tt u} to {\tt Unit}.
\end{itemize}
\end{slide}

\begin{slide}{Step 5: Implementing {\tt flowThrough}: removing kills}
\begin{verbatim}
// Take out kill set
Iterator boxIt = s.getDefBoxes()
                     .iterator();
while( boxIt.hasNext() ) 
{
    ValueBox box = 
         (ValueBox) boxIt.next();
    Value value = box.getValue();
    if( value instanceof Local )
        in.remove( value );
}
\end{verbatim}
\end{slide}

\begin{slide}{On {\tt DefBoxes}}
\vspace*{-0.1in}
{\tt List defBoxes = ut.getDefBoxes();}

\vspace*{-0.05in}
\begin{itemize}
\item method {\red \tt ut.getDefBoxes()} returns a list of {\tt
ValueBox}es, corresponding to all {\tt Value}s which get defined
in {\tt ut}, a {\tt Unit}. 

\item non-empty for {\tt IdentityStmt} and {\tt AssignStmt}.
\end{itemize}

\vspace*{-0.08in}
\begin{center}
\fbox{\tt s: \fbox{x} = \fbox{y} op \fbox{z};}
\end{center}

\vspace*{0.05in}
{\tt getDefBoxes(s) = \{\fbox{x}\}}\\
\qquad \qquad \begin{minipage}{0.7\textwidth} 
({\tt List} containing a {\tt ValueBox} containing a {\tt Local})
\end{minipage}

\end{slide}

\begin{slide}{On {\tt Value}s and {\tt Box}es}
\verb+ValueBox defBox = +\\
\verb+          (ValueBox)defBoxes.get(0);+\\
{\red \verb+Value value = defBox.getValue();+}

\begin{itemize}
\item {\tt getValue()}: Dereferencing a pointer.\\
\qquad \qquad \qquad \qquad \fbox{\tt x} $\rightarrow$ {\tt x}
\end{itemize}

\verb+if (value instanceof Local) {+

\begin{itemize}
\item Only care about defs of {\tt Local}s here.
\end{itemize}
\end{slide}

\begin{slide}{Step 5: Implementing {\tt flowThrough}: adding gens}
\begin{verbatim}
// Add gen set
boxIt = s.getUseBoxes().iterator();
while( boxIt.hasNext() ) 
{
    ValueBox box = 
         (ValueBox) boxIt.next();
    Value value = box.getValue();
    if( value instanceof Local )
        in.add( value );
}
\end{verbatim}
\end{slide}

\begin{slide}{On {\tt UseBoxes}}
\vspace*{-0.1in}
Opposite of defBoxes.

{\tt List useBoxes = ut.getUseBoxes();}

\vspace*{-0.05in}
\begin{itemize}
\item method {\red \tt ut.getUseBoxes()} returns a list of {\tt
ValueBox}es, corresponding to all {\tt Value}s which get used
in {\tt ut}, a {\tt Unit}. 

\item non-empty for most Soot {\tt Stmt}s.
\end{itemize}

\vspace*{-0.08in}
\begin{center}
\fbox{\tt s: \fbox{x} = \fbox{y} op \fbox{z};}
\end{center}

\vspace*{0.05in}
{\tt getUseBoxes(s) = \{\fbox{y}, \fbox{z}\}}\\
\qquad \qquad \begin{minipage}{0.8\textwidth} 
({\tt List} containing two {\tt ValueBox}es, each containing a {\tt Local})
\end{minipage}

\end{slide}

\begin{slide}{Step 6: Initial values}
\vspace*{-0.1in}
$\bullet$ Soundly initialize IN, OUT sets prior to analysis.

\begin{itemize}

\item Create initial sets ({\tt emptySet} from constr.)\\
{\tt void newInitialFlow()}\\
\qquad {\tt \{ return emptySet.clone(); \} }

\item Create initial sets for entry nodes\\
{\tt void entryInitialFlow() \{ ... \} }

\vspace*{0.09in}

Usually {\tt newInitialFlow()} returns the \\ \quad most aggressive result
$\top$; {\tt entryInitialFlow()} \\ \quad assigns
 $\mbox{\tt OUT}(\mbox{start}) 
\leftarrow\ \perp$.
\end{itemize}
\end{slide}

\begin{slide}{Flow Sets and Soot}
\vspace*{-0.1in}
Using a {\tt FlowSet} is not mandatory, but helpful.

\quad

Impls: {\tt ToppedSet}, {\tt ArraySparseSet}, \\
\qquad \qquad {\tt ArrayPackedSet}

\quad

\begin{tabular}{ll}
\begin{minipage}{0.5\textwidth}
{\small \tt 
// $c = a \cap b$ \\
a.intersection(b, c); \\

// $d = \overline{c}$\\
c.complement(d);
}
\end{minipage} &
\begin{minipage}{0.3\textwidth}
{\small \tt
// $c = a \cup b$ \\
a.union(b,c);\\

// $d = d \cup \{ \mbox{v} \}$\\
d.add(v);
}
\end{minipage}

\end{tabular}

\quad

\begin{center}
Read the JavaDoc!
\end{center}
% why flow universes?
%  * efficient encoding 
%  * we sometimes want to go a \cup \not b.
\end{slide}

% branching flow analysis

% do we really need 'copy'?  I wonder how much time is spent on that.
% if our flow set implementation has immutability, then 'copy' can be
% simple pointer assignment.

% why 'Object' rather than 'FlowSet'?  We sometimes don't want to
% wrap a HashSet into an adapting FlowSet (design choice)