\begin{slide}{Flow Analysis in Soot}
\vspace*{0.2in}
\begin{itemize}
\item Flow analysis is key part of compiler framework
\item Soot has easy-to-use framework for intraprocedural flow analysis
\item Soot itself, and its flow analysis framework, are object-oriented.
\end{itemize}
\end{slide}

\begin{slide}{Four Steps to Flow Analysis}
\begin{enumerate}
\item Forward or backward?  Branched or not?

\item Decide what you are approximating.\\
What is the domain's confluence operator?

\item Write equation for each kind of IR statement.

\item State the starting approximation.
\end{enumerate}
\end{slide}

\begin{slide}{HOWTO: Soot Flow Analysis}
A checklist of your obligations:
\begin{enumerate}
\item Subclass \verb+*FlowAnalysis+
\item Implement abstraction: {\tt merge()}, {\tt copy()}
\item Implement flow function {\tt flowThrough()}
\item Implement initial values: {\tt entryInitialFlow()} and {\tt
newInitialFlow()}
\item Implement constructor \\ \quad (it must call {\tt doAnalysis()})
\end{enumerate}
\end{slide}

\begin{slide}{HOWTO: Soot Flow Analysis II}
Soot rewards you with:
\begin{itemize}
\item impls of abstraction domains (flow sets)
\begin{itemize}
\item standard abstractions trivial to implement;
\end{itemize}
\item an implemented flow analysis namely,
\begin{itemize}
\item {\tt doAnalysis()} method:
executes intraprocedural analyses on a
CFG using a worklist algorithm.
\end{itemize}
\end{itemize}
\end{slide}


\begin{slide}{Outline: Soot Flow Analysis Examples}
Will describe how to implement a flow analysis in Soot and present examples:
\begin{itemize}
\item live locals
\item branched nullness testing
\end{itemize}
\end{slide}

\begin{slide}{Flow Analysis Hierarchy}
\Tree [.AbstractFlowAnalysis [.BranchedFlowAnalysis Forward ] [.FlowAnalysis Forward Backward ] ]

\end{slide}

\begin{slide}{Soot Flow Analyses}
\begin{center}
{\small 
\Tree [.AbstractFlowAnalysis 
[.BranchedFlowAnalysis [.Forward Casts Nullness ] ] 
[.FlowAnalysis [.Forward {PRE analy's\\Avail. Expr.\\Array Bds} ] [.Backward { PRE analy's \\ Liveness }  ] ] 
]
}
\end{center}
\end{slide}

\begin{slide}{Running Example 1: Live Variables}
\vspace*{-0.2in} 
A local variable {\tt v} is {\red live} at $s$ if there exists some
statement $s'$ using {\tt v} and a control-flow path from $s$ to $s'$ free
of definitions of {\tt v}.

\quad

\begin{center}
\input{lv-example.eepic}
\end{center}
\end{slide}

\begin{slide}{Another Example of Live Locals}
A local variable {\tt v} is {\red live} at $s$ if there exists some
statement $s'$ using {\tt v} and a control-flow path from $s$ to $s'$ free
of definitions of {\tt v}.

\quad

\begin{center}
\input{lv-example-specific.eepic}
\end{center}
\end{slide}

\begin{slide}{Steps to a Flow Analysis}
As we've seen before:
\begin{enumerate}
\item Subclass \verb+*FlowAnalysis+
\item Implement abstraction: {\tt merge()}, {\tt copy()}
\item Implement flow function {\tt flowThrough()}
\item Implement initial values: {\tt entryInitialFlow()} and {\tt
newInitialFlow()}
\item Implement constructor \\ \quad (it must call {\tt doAnalysis()})
\end{enumerate}
\end{slide}

\begin{slide}{Step 1: Forward or Backward?}

Live variables is a backward flow analysis, since flow
f$^{\mbox{\scriptsize n}}$ computes {\sf IN} sets from {\sf OUT} sets.

\qquad

In Soot, we subclass {\tt \red BackwardFlowAnalysis}.

\qquad

{\red \tt class LiveVariablesAnalysis \\ \qquad extends BackwardFlowAnalysis}
\end{slide}

\begin{slide}{Step 2: Abstraction domain}
\vspace*{-0.2in}

Domain for Live Variables: sets of {\tt Local}s\\
Partial order is subset inclusion

\begin{center}
\scalebox{0.95}{
\input{lv.eepic}}
\mbox{\qquad }
\end{center}
\vspace*{-0.1in}

In Soot, we use a {\tt BoundedFlowSet}:
\begin{center}
{\tt soot.toolkits.scalar.ArraySparseSet} 
\end{center}
\end{slide}

\begin{slide}{Implementing an Abstraction}
\vspace*{-0.1in}
Need to implement {\tt copy()}, {\tt merge()} methods:
\begin{center}
\input{copy-bkwd.eepic}
\end{center}
{\tt copy()} brings IN set to predecessor's OUT set.

$\qquad$

\begin{center}
\input{merge-bkwd.eepic}
\end{center}
{\tt merge()} joins two IN sets to make an OUT set.
\end{slide}

\begin{slide}{More on Implementing an Abstraction}
Signatures:
{\small 
\[ \mbox{\tt \begin{tabular}{r@{}l}
                 void merge(&Object src1, Object src2,\\
                            &Object dest);\\
                 void copy(&Object src, Object dest);
\end{tabular}}\]
}

We delegate implementation to {\tt FlowSet}.
\end{slide}

\begin{slide}{Flow Sets and Soot}
\vspace*{-0.1in}
Using a {\tt FlowSet} is not mandatory, but helpful.

\quad

Impls: {\tt ToppedSet}, {\tt ArraySparseSet}, \\
\qquad \qquad {\tt ArrayPackedSet}

\quad

\begin{tabular}{ll}
\begin{minipage}{0.5\textwidth}
{\small \tt 
// $c = a \cap b$ \\
a.intersection(b, c); \\

// $d = \overline{c}$\\
c.complement(d);
}
\end{minipage} &
\begin{minipage}{0.3\textwidth}
{\small \tt
// $c = a \cup b$ \\
a.union(b,c);\\

// $d = d \cup \{ \mbox{v} \}$\\
d.add(v);
}
\end{minipage}

\end{tabular}

\quad

\begin{center}
Read the JavaDoc!
\end{center}
% why flow universes?
%  * efficient encoding 
%  * we sometimes want to go a \cup \not b.
\end{slide}

\begin{slide}{Digression: types of {\tt FlowSet}s}
\vspace*{-0.1in}
Which {\tt FlowSet} do you want?
\begin{itemize}
%\item {\tt ArraySparseSet}: represents as simple array; 
%can't be complemented, needs no initial universe
\item {\tt ArraySparseSet}:

\qquad \begin{tabular}{|c|c|c|c|c|} \hline
foo & bar & z & \\ \hline
\end{tabular}

(simplest possible)

%% \item {\tt ArrayPackedSet}: represents as bitvector array;
%% can be complemented, needs initial universe

\item {\tt ArrayPackedSet}:

\qquad \begin{tabular}{|c|c|c|} \hline
00100101 & 10101111 & 10000000 \\ \hline
\end{tabular}

(can complement, need universe)

\item {\tt ToppedSet}: 

\qquad {\tt FlowSet \& \fbox{0/1} }

(adjoins a $\top$ to another {\tt FlowSet})

%$\top$ is above all other flowset elts (used in CSE).
\end{itemize}
\end{slide}

\begin{slide}{Step 2: {\tt copy()} for live variables}
\begin{verbatim}
protected void copy(Object src, 
                    Object dest) {
  FlowSet sourceSet = (FlowSet)src,
      destSet = (FlowSet) dest;

\end{verbatim}    
{\red\verb+  sourceSet.copy(destSet);+}
\begin{verbatim}
}
\end{verbatim}

\qquad

Use {\tt copy()} method from {\tt FlowSet}.
\end{slide}

\begin{slide}{Step 2: {\tt merge()} for live variables}
In live variables, a variable {\tt v} is live if there exists {\red any} path
from {\tt d} to {\tt p}, so we use {\red union}.

\qquad

Like {\tt copy()}, use {\tt FlowSet}'s {\tt union}:

\vspace*{0.05in}

\begin{verbatim}
  void merge(...) {
    // [cast Objects to FlowSets]
\end{verbatim}
{\red\verb+    src1Set.union(src2Set, destSet);+}\\
\verb+  }+

\vspace*{0.1in}

One might also use {\tt intersection()}, or implement a more exotic merge.

\end{slide}

\begin{slide}{Step 3: Flow equations}
\vspace*{-0.1in}

Goal: At a stmt like {\tt x = y * z}:\\
\qquad \qquad {\red -- } def {\tt x};\\
\qquad \qquad {\red + } uses {\tt y}, {\tt z}.

\vspace*{0.1in}

How? Implement this method:
\begin{verbatim}
    protected void flowThrough
                 (Object srcValue, 
                  Object u, 
                  Object destValue)
\end{verbatim}
\end{slide}

\begin{slide}{Step 3: Casting \& Copying}
Start by:
\begin{itemize}
\item casting {\tt srcValue}, {\tt destValue} to {\tt FlowSet}.

\item casting {\tt u} to {\tt Unit ut}.

\item copying {\tt src} to {\tt dest}.
\end{itemize}

In code:

\begin{verbatim}
   FlowSet src = (FlowSet)srcValue,
           dest = (FlowSet)destValue;
   Unit ut = (Unit)u;
   dest.copy( src );
\end{verbatim}
\end{slide}

\begin{slide}{Step 3: Implementing {\tt flowThrough}}
Must decide what happens at each statement (in general, need to switch
on stmt type):
\begin{center}
\scalebox{1.3}{
\input{flowthrough-bkwd.eepic}}
\end{center}
{\tt flowThrough} is the brains of a flow analysis.
\end{slide}

\begin{slide}{Step 3: {\tt flowThrough} for live locals}
\vspace*{0.1in}
A local variable {\tt v} is {\red live} at $s$ if there exists some
statement $s'$ containing a use of {\tt v},
and a control-flow path from $s$ to $s'$ free
of def'ns of {\tt v}.

$\quad$

Don't care about the type of stmt we're analyzing, because Soot
provides abstract accessors to values used and defined in a stmt.

\end{slide}

\begin{slide}{Step 3: Implementing {\tt flowThrough}: removing kills}
\begin{verbatim}
// Take out kill set:
//  for each local v def'd in 
//  this stmt, remove v from dest
Iterator boxIt = ut.getDefBoxes()
                     .iterator();
while( boxIt.hasNext() ) {
    ValueBox box = 
         (ValueBox) boxIt.next();
    Value value = box.getValue();
    if( value instanceof Local )
        dest.remove( value );
}
\end{verbatim}
\end{slide}

\begin{slide}{What is a {\tt DefBox}?}
\vspace*{-0.1in}
{\tt List defBoxes = ut.getDefBoxes();}

\vspace*{-0.05in}
\begin{itemize}
\item method {\red \tt ut.getDefBoxes()} returns a list of {\tt
ValueBox}es, corresponding to all {\tt Value}s which get defined
in {\tt ut}, a {\tt Unit}. 

\item non-empty for {\tt IdentityStmt} and {\tt AssignStmt}.
\end{itemize}

\vspace*{-0.08in}
\begin{center}
\fbox{\tt ut: \fbox{x} = \fbox{y} op \fbox{z};}
\end{center}

\vspace*{0.05in}
{\tt getDefBoxes(ut) = \{\fbox{x}\}}\\
\qquad \qquad \begin{minipage}{0.7\textwidth} 
({\tt List} containing a {\tt ValueBox} containing a {\tt Local})
\end{minipage}

\end{slide}

\begin{slide}{On {\tt Value}s and {\tt Box}es}
%% \vspace*{-0.1in}
%% \verb+Iterator boxIt = +\\
%% \verb+       ut.getDefBoxes().iterator();+\\
%% \verb+while (boxIt.hasNext()) {+\\
%% \verb+    ValueBox box = +\\
%% \verb+        (ValueBox) boxIt.next();+\\
{\red \verb+    Value value = defBox.getValue();+}

\begin{itemize}
\item {\tt getValue()}: Dereferencing a pointer.\\
\qquad \qquad \qquad \qquad \fbox{\tt x} $\to$ {\tt x}
\end{itemize}

{\red \verb+    if (value instanceof Local) {+}

\begin{itemize}
\item Only care about defs of {\tt Local}s here.
\end{itemize}
\end{slide}

\begin{slide}{Step 3: Implementing {\tt flowThrough}: adding gens}
\vspace*{-0.1in}
\begin{verbatim}
// Add gen set
//  for each local v used in 
//  this stmt, add v to dest
boxIt = ut.getUseBoxes().iterator();
while( boxIt.hasNext() ) 
{
    ValueBox box = 
         (ValueBox) boxIt.next();
    Value value = box.getValue();
    if( value instanceof Local )
        dest.add( value );
}
\end{verbatim}

N.B. our analysis is generic, not restricted to Jimple.
\end{slide}

\begin{slide}{On {\tt UseBoxes}}
\vspace*{-0.1in}
Opposite of defBoxes.

{\tt List useBoxes = ut.getUseBoxes();}

\vspace*{-0.05in}
\begin{itemize}
\item method {\red \tt ut.getUseBoxes()} returns a list of {\tt
ValueBox}es, corresponding to all {\tt Value}s which get used
in {\tt ut}, a {\tt Unit}. 

\item non-empty for most Soot {\tt Stmt}s.
\end{itemize}

\vspace*{-0.08in}
\begin{center}
\fbox{\tt ut: \fbox{x} = \fbox{y} op \fbox{z};}
\end{center}

\vspace*{0.05in}
{\tt getUseBoxes(ut) = \{\fbox{y}, \fbox{z}, \fbox{y op z}\}}\\
\qquad \qquad \begin{minipage}{0.8\textwidth} 
({\tt List} containing two {\tt ValueBox}es, each containing a {\tt Local})
\end{minipage}

\end{slide}

\begin{slide}{Step 4: Initial values}
\vspace*{-0.15in}
$\bullet$ Soundly initialize IN, OUT sets prior to analysis.

\vspace*{-0.1in}
\begin{itemize}
\item Create initial sets for exit nodes\\
{\tt void entryInitialFlow() \\ 
\qquad \{return new ArraySparseSet();\} }

\item Create initial sets\\
{\tt void newInitialFlow()}\\
\qquad {\tt \{return new ArraySparseSet();\} }

\end{itemize}

Want conservative initial value at entry points, optimistic
value at all other nodes.
\end{slide}

\begin{slide}{Step 5: Implement constructor}
\begin{verbatim}
LiveVariablesAnalysis(UnitGraph g)
{
    super(g);

    doAnalysis();
    
}
\end{verbatim}
Causes the flow sets to be computed, using Soot's flow
analysis engine.

\quad

In other analyses, we precompute values.
\end{slide}

% branching flow analysis

\begin{slide}{Running Example 2: Branched Nullness}
\vspace*{-0.2in} 
A local variable {\tt v} is {\red non-null} at $s$ if all
control-flow paths reaching $s$ result in {\tt v} being
assigned a value different from {\tt null}.

\begin{center}
\input{br-example.eepic}
\end{center}
\end{slide}

\begin{slide}{Example: Branched nullness}

A local variable {\tt v} is {\red non-null} at $s$ if all control-flow
paths from a method's start node to $s$ result in {\tt v} being
assigned a value different from {\tt null} at $s$.

\begin{center}
\input{lv-example-specific.eepic}
\end{center}

\end{slide}

\begin{slide}{HOWTO: Soot Flow Analysis (bis)}
Again, here's what to do:
\begin{enumerate}
\item Subclass \verb+*FlowAnalysis+
\item Implement abstraction: {\tt merge()}, {\tt copy()}
\item Implement flow function {\tt flowThrough()}
\item Implement initial values: {\tt entryInitialFlow()} and {\tt
newInitialFlow()}
\item Implement constructor \\ \quad (it must call {\tt doAnalysis()})
\end{enumerate}
\end{slide}

\begin{slide}{Step 1: Forward or Backward?}

Nullness is a branched forward flow analysis, since flow
f$^{\mbox{\scriptsize n}}$ computes {\sf OUT} sets from {\sf IN} sets, 
sensitive to branches

\qquad

In Soot, we subclass {\tt \red BranchedForwardFlowAnalysis}.

\qquad

{\small \red \tt class NullnessAnalysis \\ 
           \qquad extends BranchedForwardFlowAnalysis \{ }
\end{slide}

\begin{slide}{Step 2: Abstraction domain}
\vspace*{-0.2in}

Domain: sets of {\tt Local}s known to be non-null\\
Partial order is subset inclusion.

\quad

(More complicated abstractions possible for this problem; e.g. 
$\perp, \top, \mbox{\tt null}, \mbox{non-{\tt null}}$ per-local.)

\quad

Again, use {\tt ArraySparseSet}, which we use to implement:
{\small 
\[ \mbox{\tt \begin{tabular}{r@{}l}
                 void merge(&Object in1, Object in2,\\
                            &Object out);\\
                 void copy(&Object src, Object dest);
\end{tabular}}\]
}
\end{slide}

\begin{slide}{Step 2: {\tt copy()} for nullness}
Same as for live locals.

\begin{verbatim}
protected void copy(Object src, 
                    Object dest) {
  FlowSet sourceSet = (FlowSet)src,
      destSet = (FlowSet) dest;

\end{verbatim}    
{\red\verb+  sourceSet.copy(destSet);+}
\begin{verbatim}
}
\end{verbatim}

\qquad

Use {\tt copy()} method from {\tt FlowSet}.
\end{slide}

\begin{slide}{Step 2: {\tt merge()} for nullness}
In branched nullness, a variable {\tt v} is non-null if it is non-null
on all paths from {\tt start} to {\tt s}, so we use intersection.

\qquad

Like {\tt copy()}, use {\tt FlowSet} method -- here, {\tt intersection()}:

\vspace*{0.05in}

\begin{verbatim}
  void merge(...) {
    // [cast Objects to FlowSets]
\end{verbatim}
{\red\verb+    srcSet1.intersection(srcSet2,+\\
     \verb+                         destSet);+}\\
\verb+  }+

\end{slide}


\begin{slide}{Step 3: Flow equations}
\vspace*{-0.1in}

\end{slide}

%% Goal: At a stmt like {\tt x = y + z}, remove def {\tt x} from the
%% flow set and add uses {\tt y} and {\tt z}.

%% \vspace*{0.1in}

%% Must implement this method:
%% \begin{verbatim}
%%     protected void flowThrough
%%                  (Object inValue, 
%%                   Object u, 
%%                   Object outValue)
%% \end{verbatim}

%% We start by:
%% \begin{itemize}
%% \item casting {\tt inValue}, {\tt outValue} to {\tt FlowSet}.

%% \item casting {\tt u} to {\tt Unit}.
%% \end{itemize}
%% \end{slide}

%% \begin{slide}{Step 5: Implementing {\tt flowThrough}: removing kills}
%% \begin{verbatim}
%% // Take out kill set
%% Iterator boxIt = s.getDefBoxes()
%%                      .iterator();
%% while( boxIt.hasNext() ) 
%% {
%%     ValueBox box = 
%%          (ValueBox) boxIt.next();
%%     Value value = box.getValue();
%%     if( value instanceof Local )
%%         in.remove( value );
%% }
%% \end{verbatim}
%% \end{slide}

%% \begin{slide}{Step 5: Implementing {\tt flowThrough}: adding gens}
%% \begin{verbatim}
%% // Add gen set
%% boxIt = s.getUseBoxes().iterator();
%% while( boxIt.hasNext() ) 
%% {
%%     ValueBox box = 
%%          (ValueBox) boxIt.next();
%%     Value value = box.getValue();
%%     if( value instanceof Local )
%%         in.add( value );
%% }
%% \end{verbatim}
%% \end{slide}

%% \begin{slide}{Step 6: Initial values}

%% In constructor, we precompute full set (all locals):

%% {\small \tt 
%% \qquad fullSet = emptySet.clone();\\
%% \qquad Iterator it = ((UnitGraph)g).\\
%% \qquad \qquad    getBody().getLocals().iterator(); \\
%% \qquad while (it.hasNext()) \{ \\
%% \qquad \qquad Local v = (Local)it.next();\\
%% \qquad \qquad if (v.getType() instanceof RefType)\\
%% \qquad \qquad \qquad fullSet.add(v);\\
%% \qquad \qquad \} \\
%% \qquad \} }

%% \end{slide}


\begin{slide}{Step 4: Initial values}
\vspace*{-0.1in}
Initialize IN, OUT sets.
\begin{itemize}

\item Create initial sets ($\top$ from constr.)\\
{\tt void newInitialFlow() \{\\
\qquad \tt \{ return fullSet.clone(); \} }

\vspace*{0.1in}

\item Create entry sets ({\tt emptySet} from constr.)\\
{\tt void entryInitialFlow()}\\
\qquad {\tt \{ return emptySet.clone(); \} }
\end{itemize}
\end{slide}


% do we really need 'copy'?  I wonder how much time is spent on that.
% if our flow set implementation has immutability, then 'copy' can be
% simple pointer assignment.

% why 'Object' rather than 'FlowSet'?  We sometimes don't want to
% wrap a HashSet into an adapting FlowSet (design choice)